{
    "data": {
        "success": true,
        "data": [{
            "id": "5bd4772a14e994202cd5bdb7",
            "author_id": "504c28a2e2b845157708cb61",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>2018年10月27日晚上，突然收到服务器不能访问的告警通知，拜托了狼叔 <a href=\"/user/i5ting\">@i5ting</a> 帮忙看看，结果登不上也ping不通。\n后来收到短信，发现是被ucloud封了，短信内容如下：</p>\n<blockquote>\n<p>【UCloud】尊敬的UCloud用户，您的IP：123.59.77.142  存在URL ：<a href=\"https://cnodejs.org/topic/57239bce5a26c4a841ecbf01\">https://cnodejs.org/topic/57239bce5a26c4a841ecbf01</a> （详细信息请查看邮箱）包含违禁内容（包括但不限于翻墙等），违反了国家有关法律法规。目前依主管单位要求，对您的IP予以封停，请您尽快处理违规内容。待处理完成后请联系技术支持重新开启业务。[4000188113]</p>\n</blockquote>\n<p>然后联系了ucloud的客服，一下就打通了，对方态度挺好处理问题也快。ucloud说是运营商那边封的，不是他们的检测机制。所以需要联系运营商解决。\n考虑到各位亲爱的网友们的行为我无法控制，那么一直跟越来越严格的审查系统对抗只会让自己疲惫，所以我就站点迁到国外。来到了aws jp。</p>\n<p>我大致测了测，电信和移动的访问速度非常快，100ms以内，联通会慢一点，400ms以内吧。</p>\n<p>建议翻墙访问。</p>\n</div>",
            "title": "服务器迁移至 aws 日本机房",
            "last_reply_at": "2019-03-22T02:33:51.713Z",
            "good": false,
            "top": true,
            "reply_count": 178,
            "visit_count": 18458,
            "create_at": "2018-10-27T14:33:14.694Z",
            "author": {
                "loginname": "alsotang",
                "avatar_url": "https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"
            }
        }, {
            "id": "5c73d9c2ab86b86ddf6b2b4a",
            "author_id": "51f0f267f4963ade0e08f503",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>更灵活的机动、更快的效率、更高的产能\nServerless - 解放的不仅仅是生产力，更是一种全新的思维方式。</p>\n<p>百姓网 Hax、上线了郭达峰、ThoughtWorks 陈欢、阿里云杜万、淘宝冰森等优秀分享者，\n期待与你一起进入嗨翻 server 的新场景。</p>\n<p><img src=\"//static.cnodejs.org/FlbUfz7IHVgS4DwmjSrXKiL9fMRl\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FlDAitTvYWpWsudI8VGjfjGGXYRr\" alt=\"image.png\"></p>\n<p>时间：03 月 16 日周六\n地点：上海证大五道口广场</p>\n<p>报名链接：<a href=\"https://survey.alibaba.com/apps/zhiliao/tZc2WjLe2\">https://survey.alibaba.com/apps/zhiliao/tZc2WjLe2</a>\n活动主页：<a href=\"https://taobaofed.github.io/nodejs-club/\">https://taobaofed.github.io/nodejs-club/</a></p>\n</div>",
            "title": "Node 地下铁第八期「上海站」线下沙龙邀约 - Let's Go Serverless!",
            "last_reply_at": "2019-03-21T01:39:18.715Z",
            "good": false,
            "top": true,
            "reply_count": 41,
            "visit_count": 3909,
            "create_at": "2019-02-25T12:04:18.826Z",
            "author": {
                "loginname": "lellansin",
                "avatar_url": "https://avatars2.githubusercontent.com/u/2081487?v=4&s=120"
            }
        }, {
            "id": "5c7c8d8b5b8cb21491ca56b6",
            "author_id": "5c247db93898674067a78f02",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>egg.js中实现RESTfull api，vue请求post数据提示 missing csrf token</p>\n<p><img src=\"//static.cnodejs.org/FsadJ4J2Ln6qZilgzTaTWCZmYhzQ\" alt=\"2.png\"></p>\n</div>",
            "title": "egg.js中实现RESTfull api，vue请求post数据提示 missing csrf token",
            "last_reply_at": "2019-03-22T13:42:04.261Z",
            "good": false,
            "top": false,
            "reply_count": 11,
            "visit_count": 694,
            "create_at": "2019-03-04T02:29:31.323Z",
            "author": {
                "loginname": "gougou168",
                "avatar_url": "https://avatars2.githubusercontent.com/u/46184813?v=4&s=120"
            }
        }, {
            "id": "5c94d102fd41137eb76609b7",
            "author_id": "5c94ccaffd41137eb766099b",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><a href=\"https://www.writeathon.cn\"><strong>Writeathon</strong></a>是一款为写作而设计、为写作而开发的工具，基于极简理念，提供简洁、高效、专注的写作体验。主要亮点：</p>\n<ul>\n<li><strong>沉浸式体验</strong> ：极简设计，聚焦写作区域；</li>\n<li><strong>实用功能</strong> ：<a href=\"https://github.github.com/gfm\">GFM</a>语法、Zen模式、分栏模式 、夜间模式、语法提示/格式工具、图床、内容快照…提升效率，享受写作乐趣；</li>\n<li><strong>写作辅助</strong> ：内置思维导图Zenminder、写作统计和写作目标设置，辅助文章构思，随时掌握写作进度。</li>\n</ul>\n<h2>设计</h2>\n<p>主界面将写作区域最大化，其余功能区安排在窗口四角，最大限度减少干扰。</p>\n<p>整体设计采用黑白灰三色，配合简洁的动效，带来清爽、轻便的体验。</p>\n<p><img src=\"//static.cnodejs.org/Fl6Z66CVrh6pIxXIsBdHQ7YFNXbu\" alt=\"ui.png\"></p>\n<h2>写作统计</h2>\n<p>提供故事、文章和字数总计，提供写作日历，更直观地查看写作进度，提供按月度的字数统计，可以随时掌握写作习惯。</p>\n<p><img src=\"//static.cnodejs.org/Foiu_OZwdPwBcUJZyU8litOJfsZY\" alt=\"stats-zh.png\"></p>\n<h2>个人主页</h2>\n<p>可设置个人主页，将文章发布到个人主页中。</p>\n<p><img src=\"//static.cnodejs.org/Fsy-yv4HvsRTpaxh_XQwoFAvchlX\" alt=\"profile.png\"></p>\n<h2>编辑器</h2>\n<p>内置编辑器除了支持标准的Markdown语法，如<strong>加粗</strong>、<em>斜体</em>外，还支持由Github提出的<a href=\"https://github.github.com/gfm\">GFM</a>语法，其增加了<strong>删除线</strong>、<strong>代码块</strong>、<strong>语法高亮</strong>、<strong>表格</strong>，此外还基于<a href=\"https://katex.org/\">Katex</a>实现对<a href=\"https://zh.wikipedia.org/wiki/TeX\">Tex</a>数学公式的支持。</p>\n<p>同时提供<strong>Excel/Word表格复制</strong>、<strong>自增列表</strong>、<strong>自动补全括号</strong>、<strong>高亮匹配括号</strong>、<strong>折叠代码/链接</strong>、<strong>智能标点</strong>等增强功能。</p>\n<h3>Zenminder</h3>\n<p><strong>Zenminder</strong>是一个专门为写作设计的思维导图工具，提供主题节点布局（多层级）、自由节点布局、自由节点连接、多行文本节点等功能，可以作为提纲、人物、情节和文章结构的构思工具。</p>\n<p>同时提供双栏模式，可一边查看导图一边写作。亦可将主题节点结构插入到文章中，然后展开写作。</p>\n<blockquote>\n<p>**提示：**Zenminder请在最新的Chrome浏览器中使用。</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/Fk9UHYkslCgOz210lR7NvC_e6Tzc\" alt=\"zenminder.png\"></p>\n<h3>Zen模式</h3>\n<p><strong>Zen模式</strong>整合了全屏和打字机效果，进入该模式，编辑器的高度将会固定为屏幕的一半，同时高亮当前编辑行，将视觉焦点始终保持在屏幕的中部。</p>\n<p><img src=\"//static.cnodejs.org/FuofKmNZMrsqYGN_uMZov609DoIf\" alt=\"zenmode.png\"></p>\n<h3>内容快照</h3>\n<p>系统会根据文章自动保存间隔进行备份，与一般自动备份不同的是，还可以直观地查看历史文章的内容。</p>\n<blockquote>\n<p>**提示：**文章自动保存间隔可在设置中调整，目前支持1、5、10分钟。</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/FirrvBTq3PnUHeQk0H8bbauvLrwr\" alt=\"page_snapshot.png\"></p>\n<h3>分栏模式</h3>\n<p><strong>分栏模式</strong>同时显示写作和预览区域，能够实时预览Markdown文档渲染结果。</p>\n<p><img src=\"//static.cnodejs.org/Fud55i1jML7d3NdqI4iH3Zji-95-\" alt=\"splitmode.png\"></p>\n<h3>夜间模式</h3>\n<p>编辑器、Zenminder均支持夜间模式，该模式下的字体、按钮颜色均有相应的优化。</p>\n<blockquote>\n<p>**提示：**目前夜间模式仅支持编辑器范围，后续版本会实现全局夜间模式。</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/FptqN_4kciyCeHYXmjrEFWgC3qu_\" alt=\"nightmode.png\"></p>\n<h3>语法提示/格式工具</h3>\n<p>通过输入‘@’可获取Markdown语法提示，同时选中文字会出现格式工具栏，目前提供加粗、斜体、删除、引用、有序列表、无序列表和待办列表等操作。</p>\n<p><img src=\"//static.cnodejs.org/Fmnbhmte8tx6bQK5kKU4FhMUu6Bm\" alt=\"hint.png\"></p>\n<h3>实时目录</h3>\n<p>根据Markdown语法中的标题，可生成最多四级目录，目录可以在预览和分享模式中切换显示并进行页内导航。</p>\n<p><img src=\"//static.cnodejs.org/FoOYXbLPGJYTcjX44WpmkjP7rkq4\" alt=\"toc.png\"></p>\n<h3>语法纠错</h3>\n<p>基于<a href=\"https://ai.baidu.com/tech/nlp/text_corrector\">百度AI</a>的文章纠错接口提供<strong>中文纠错</strong>功能，开启后可对错别字词进行替换操作。</p>\n<p><img src=\"//static.cnodejs.org/Ft0sxllkt1mD7GmyCucCTyuDb-2w\" alt=\"lexicalcheck.png\"></p>\n<h3>图床</h3>\n<p>支持上传本地图片到图床。</p>\n<blockquote>\n<p>此为实验性功能，当前仅支持<a href=\"https://sm.ms/\">SM.MS</a>，后续会整合更多图床。</p>\n</blockquote>\n<h3>音效</h3>\n<p>精心收集了<strong>按键</strong>、<strong>回车</strong>和<strong>空格</strong>按键音效，以及<strong>雨</strong>、<strong>大海</strong>、<strong>溪流</strong>等白噪音，增加写作乐趣。</p>\n<h3>分享</h3>\n<p>可以开启文章分享功能，可设置分享密码，通过链接和二维码在Web（包括移动端）中分享。</p>\n<h3>写作目标</h3>\n<p>可以设定字数和时间目标，倒计时达到一半和结束均会提示。</p>\n<h3>导出</h3>\n<p>目前支持导出markdown、pdf和html格式的文档，后续会逐步支持epub、word等格式。</p>\n<h3>移动端适配</h3>\n<p>移动端Web能够查看分享的文章，并进行简单的目录、文章编辑等操作。</p>\n<h3>其它功能</h3>\n<p>包括：<strong>文章移动</strong>、<strong>文章排序</strong>、<strong>简单搜索</strong>、<strong>还原已删除文章</strong>、<strong>最近打开的文章</strong>。</p>\n<h2>产品计划</h2>\n<p>未来，在继续增强写作体验的基础上，会在写作灵感、写作辅助、写作训练等方面进行探索，<strong>Writeathon</strong>的目标不仅是一款好用的工具，更希望能帮助用户创作出更多激动人心的作品。</p>\n<h2>意见反馈</h2>\n<p>反馈社区：<a href=\"https://support.qq.com/products/45320\">吐个槽</a>\nQQ群：972622254\n邮箱：<a href=\"mailto:690090@qq.com\">690090@qq.com</a>\n微博：<a href=\"http://weibo.com/writeathon\">writeathon</a>\n微信公众号：writeathon\n<img src=\"//static.cnodejs.org/FtOinadN0dObZ1GNmXZpktIOlA_2\" alt=\"wechat_writeathon_qrcode.jpg\"></p>\n</div>",
            "title": "【Writeathon】-极简、高效的写作平台（基于Eggjs+Nuxt+Bulma实现）",
            "last_reply_at": "2019-03-22T12:13:55.017Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 46,
            "create_at": "2019-03-22T12:11:46.983Z",
            "author": {
                "loginname": "Hcs66",
                "avatar_url": "https://avatars2.githubusercontent.com/u/255027?v=4&s=120"
            }
        }, {
            "id": "5c94d050fd41137eb76609af",
            "author_id": "55c56e8a39273b9219336288",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>全职写开源代码，建立 reputation 的同时获得报酬，是程序员梦想的工作吗？</p>\n<blockquote>\n<p><a href=\"https://github.com/t9tio/open-source-jobs\">https://github.com/t9tio/open-source-jobs</a></p>\n</blockquote>\n<p><a href=\"https://github.com/t9tio/open-source-jobs\"><img src=\"https://raw.githubusercontent.com/timqian/images/master/Screen%20Shot%202019-03-22%20at%207.57.11%20PM.png\" alt></a></p>\n</div>",
            "title": "茶余饭后收集了一张提供工作机会的开源项目的列表，欢迎一起作为 markdown 工程师来改进它",
            "last_reply_at": "2019-03-22T12:08:48.256Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 38,
            "create_at": "2019-03-22T12:08:48.256Z",
            "author": {
                "loginname": "timqian",
                "avatar_url": "https://avatars3.githubusercontent.com/u/5512552?v=4&s=120"
            }
        }, {
            "id": "5c948aabfd41137eb76607eb",
            "author_id": "4efc278525fa69ac69000141",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>文档上没有看到明确说, <code>proc.kill</code> 的默认行为怎么理解?\n我遇到的是在工具当中通过 <code>child_process</code> 启动了子进程, 比如 webpack, 但是 webpack 运行的时候又有它的子进程… 结果我在 kill Webpack 的时候子进程就变成 orphan 了.  想知道 <code>proc.kill</code>  的默认行为是不是存在坑.</p>\n</div>",
            "title": "proc.kill 的默认行为如何理解?",
            "last_reply_at": "2019-03-22T11:26:39.857Z",
            "good": false,
            "top": false,
            "reply_count": 7,
            "visit_count": 102,
            "create_at": "2019-03-22T07:11:39.718Z",
            "author": {
                "loginname": "jiyinyiyong",
                "avatar_url": "https://avatars0.githubusercontent.com/u/449224?v=4&s=120"
            }
        }, {
            "id": "5c8b0a4a7ce0df3732428254",
            "author_id": "5adecaa3a86ec1f308ec2480",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>从学习 Nodejs 以来，听各路大神说 nodejs 的一大优势就是处理高并发。我是非科班出身，对于高并发的理解就是能够同时处理大量请求，第一印象就是每个请求单独起个线程处理，请求与请求之间互不干扰，然鹅…</p>\n<p>用 http 原生代码起一个服务器，接收两个请求：</p>\n<ul>\n<li><code>/a</code>：该接口内部写了个斐波拉契递归函数，执行时间大约 10s 左右</li>\n<li><code>/b</code></li>\n</ul>\n<p>实际起服务后，先请求 <code>/a</code> 接口，再请求 <code>/b</code> 接口。由于 <code>/a</code> 接口被斐波拉契函数阻塞了 10s 左右，惊讶的发现 <code>/b</code> 接口竟然一直要等到 <code>/a</code> 接口跑完才能响应。这说明 http 处理接口是一个处理完再处理下一个的，那么问题来了，10个用户同时请求同一个查询接口，假设每次查询时间为 1s，那岂不是运气差的人拿到响应肯定是在 10 秒之后。</p>\n<p>所谓高并发又到底怎么理解呢？</p>\n<pre class=\"prettyprint\"><code>var http = require(&#x27;http&#x27;)\n\nvar app = http.createServer(function (req, res) {\n    if (req.url === &#x27;&#x2F;a&#x27;) {\n        &#x2F;&#x2F; 斐波拉契函数\n        function fib(n) {\n            if (n === 0) return 0;\n            else if (n === 1) return 1;\n            else return fib(n - 1) + fib(n - 2)\n        }\n        fib(44) &#x2F;&#x2F; 执行时间要 10s 左右\n        res.end(&#x27;a is &#x27; + new Date())\n    } else if (req.url === &#x27;&#x2F;b&#x27;) {\n        res.end(&#x27;b is &#x27; + new Date())\n    }\n})\n\napp.listen(3600, function () {\n    console.log(&#x27;服务已启动&#x27;)\n})\n</code></pre></div>",
            "title": "关于 Nodejs 服务器高并发的疑问",
            "last_reply_at": "2019-03-22T11:03:15.889Z",
            "good": false,
            "top": false,
            "reply_count": 35,
            "visit_count": 1271,
            "create_at": "2019-03-15T02:13:30.302Z",
            "author": {
                "loginname": "dkvirus",
                "avatar_url": "https://avatars1.githubusercontent.com/u/29170168?v=4&s=120"
            }
        }, {
            "id": "5c2edce13898674067a7b103",
            "author_id": "5372465f3c72496d41009adc",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>截止1 月 12日晚 22:00，有效参与人数共 252 人，抽取 5 名中奖者。\n恭喜以下中奖者🎉🎉🎉🎉🎉 gofromzero,MoeXian,yxcs,caoxiaoshuai1,langjy🎉🎉🎉🎉🎉\n请评论区留下联系方式。\n<img src=\"//static.cnodejs.org/Fvx9s9EjQk7IwNrAMO5_y7zJfrej\" alt=\"image.png\"></p>\n<p>---------------- 以下是原文 ----------------</p>\n<p>新书《Node.js开发实战》热卖，大获好评，感谢大家的支持，送几本书回馈给大家。</p>\n<p>赠书办法：</p>\n<ul>\n<li>只须在本贴留言即可。</li>\n<li>从回贴评论者中随机抽取中奖者，共计 5 本，每位中奖者 1 本。</li>\n<li>获赠名单公布在本帖，并在本贴下评论 @ 每位获赠的同学。</li>\n<li>截止时间 2019 年 1 月 12 日 22:00:00 （ UTC+8 ），以评论时间为准。</li>\n<li>由于本站不支持私信，请获奖同学在本帖回复联系方式，邮箱或者任何其它能联系到你的形式。</li>\n<li>开奖后 72 小时未能回复联系方式者视为放弃。</li>\n</ul>\n<p>试读样章：<a href=\"https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg\">https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg</a>\n京东有售：<a href=\"https://item.jd.com/12460185.html\">https://item.jd.com/12460185.html</a>\n<img src=\"//static.cnodejs.org/Finp2H7di-Equ_yMWsjJY6hxYGkh\" alt=\"WechatIMG148 copy.jpg\"></p>\n</div>",
            "title": "送几本《Node.js开发实战》",
            "last_reply_at": "2019-03-22T08:31:23.310Z",
            "good": false,
            "top": false,
            "reply_count": 362,
            "visit_count": 11725,
            "create_at": "2019-01-04T04:11:13.570Z",
            "author": {
                "loginname": "meikidd",
                "avatar_url": "https://avatars0.githubusercontent.com/u/376338?v=4&s=120"
            }
        }, {
            "id": "5c949d11fd41137eb76608ab",
            "author_id": "580f6fcab37ee8fb339787ea",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FgUfHkjYr6VWmRR044Mwp9SvZaz6\" alt=\"image.png\"></p>\n</div>",
            "title": "cnpm最近两天是炸了么？？？",
            "last_reply_at": "2019-03-22T08:30:09.721Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 106,
            "create_at": "2019-03-22T08:30:09.721Z",
            "author": {
                "loginname": "lzq920",
                "avatar_url": "https://avatars0.githubusercontent.com/u/37999725?v=4&s=120"
            }
        }, {
            "id": "5c87a30dacb681372d41776c",
            "author_id": "58898ca65d4612c33919ea01",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h2>需求</h2>\n<p><img src=\"//static.cnodejs.org/Fs7iMBX7K-g0RAUPA_FIHBdyhP7l\" alt=\"requirement.jpg\"></p>\n<p>源库中的数据是以<code>BLOB</code>的形式存储的，且数据中含有中文，MySQL数据库的字符集为<code>utf8</code>，最终想要的效果就是在浏览器中以文本的形式展示源库中的数据。为了实现这一需求，尝试了2种方案：</p>\n<ul>\n<li>从Oracle层面解决，通过视图将相关字段转换成<code>VARCHAR2</code>类型后在返回，这样从Oracle中查询数据的时候，直接拿到的就是字符串类型的数据。这样做的弊端是：Oracle数据库VARCHAR2类型最大只能支持4kb，如果超过了这个大小就会出错。</li>\n<li>从Oracle取到数据后，使用Node.js转换成字符串后再存入到MySQL数据库中。</li>\n</ul>\n<p>我使用了第2种解决方案，但是过程并不是很顺利。</p>\n<h2>遇到的问题</h2>\n<p>从Oracle数据库中取到的数据，在Node.js中是<code>Buffer</code>对象，要将Buffer对象转换成字符串对Node.js来说实在是太常规了，直接<code>buffer.toString</code>就完事了，可事实并非如此，得到的字符串都是乱码。一般遇到这个问题，大家的第一反应肯定是编码问题，我也是这么想的，考虑到数据中有中文，而Node.js原生并没有支持中文的相关编码，默认是<code>utf8</code>，已经尝试过了。所以就引入了<a href=\"https://github.com/ashtuchkin/iconv-lite\">iconv-lite</a>这个模块，用来对Buffer对象进行解码，但是Oracle中使用的字符集是<code>SIMPLIFIED CHINESE_CHINA.ZHS32GB18030</code>，所以我想当然的就使用<code>GB18030</code>编码来解码，代码示例：</p>\n<pre class=\"prettyprint language-js\"><code>const iconv = require(&#x27;iconv-lite&#x27;);\n\n&#x2F;&#x2F; Convert from an encoded buffer to js string.\nconst str = iconv.decode(buffer, &#x27;gb18030&#x27;);\n</code></pre><p>结果得到的字符串还是乱码，然后我又把iconv-lite支持的所有中文编码又试了一遍，得到的字符串全都是乱码。</p>\n<h2>解决</h2>\n<p>经过一番Google和尝试后仍然没有解决，然后就在上述提到的两种方案之间来回折腾。后来在朋友的引导下，得到了一个思路：先探测Buffer对象的编码，得到确定的编码后，再进行解码。于是乎就找到了这个模块：<a href=\"https://github.com/sonicdoe/detect-character-encoding\">detect-character-encoding</a>。这个模块主要是用来探测字符编码的，使用方法也很简单，示例代码：</p>\n<pre class=\"prettyprint language-js\"><code>const fs = require(&#x27;fs&#x27;);\nconst detectCharacterEncoding = require(&#x27;detect-character-encoding&#x27;);\n\nconst fileBuffer = fs.readFileSync(&#x27;file.txt&#x27;);\nconst charsetMatch = detectCharacterEncoding(fileBuffer);\n\nconsole.log(charsetMatch);\n&#x2F;&#x2F; {\n&#x2F;&#x2F;   encoding: &#x27;UTF-8&#x27;,\n&#x2F;&#x2F;   confidence: 60\n&#x2F;&#x2F; }\n</code></pre><p>于是乎就用这个模块对上述提到的Buffer对象进行探测，得到的编码竟然是<code>UTF-16LE</code>，然后使用这个编码进行解码，果然得到了正确的字符串。问题到此彻底解决了。</p>\n<h2>注意事项</h2>\n<ul>\n<li>探测编码时请多用一些数据样例来探测，最后使用可信度最高的编码。</li>\n<li>千万不要动态探测编码，然后动态解码，因为这个模块的探测结果是随着数据的变化而变化的。</li>\n<li>使用iconv-lite模块解码时，如果编码名称中有字母，请一律使用小写字母。</li>\n<li>一定要确保从Oracle取到的数据在Node.js环境中为Buffer对象。</li>\n</ul>\n<h2>其他说明</h2>\n<ul>\n<li>连接Oracle使用的模块是<a href=\"https://github.com/oracle/node-oracledb\">oracledb</a></li>\n<li>连接MySQL使用的模块是<a href=\"https://github.com/tgriesser/knex\">knex</a></li>\n</ul>\n<h2>总结</h2>\n<p>这次遇到的问题，其实解决方案是比较清晰的，但是在对Buffer进行解码遇到问题后没有冷静下来分析，在2个解决方案之间来回折腾浪费了很多时间；当已经很明确问题出现在哪个环节时，应该借助相关工具进一步确认问题的根源所在，比如：这次在解码环节出现了问题，而问题的根源也比较清晰，就是解码时使用的编码不对，所以就应该先明确Buffer对象所使用的编码，然后再用正确的编码进行解码即可。</p>\n</div>",
            "title": "记一次从Oracle数据库取BLOB数据遇到的坑",
            "last_reply_at": "2019-03-22T08:28:54.378Z",
            "good": false,
            "top": false,
            "reply_count": 12,
            "visit_count": 456,
            "create_at": "2019-03-12T12:16:13.763Z",
            "author": {
                "loginname": "blackmatch",
                "avatar_url": "https://avatars3.githubusercontent.com/u/12443954?v=4&s=120"
            }
        }, {
            "id": "5c9465d400bcfd7eb2be4e89",
            "author_id": "4efc278625fa69ac69000229",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>前两年在边锋开发“侠客风云传”和棋牌游戏的时候用过，但是很少听说其它公司或项目用。感觉找工作和招人都不容易。用Node最多的还是前端开发。最近应聘的两家都是想做小游戏的，要求挺高但是待遇或地位不怎么样。</p>\n</div>",
            "title": "游戏后端用Node的多吗？",
            "last_reply_at": "2019-03-22T07:43:23.509Z",
            "good": false,
            "top": false,
            "reply_count": 5,
            "visit_count": 278,
            "create_at": "2019-03-22T04:34:28.211Z",
            "author": {
                "loginname": "lushisang",
                "avatar_url": "https://avatars0.githubusercontent.com/u/197572?v=4&s=120"
            }
        }, {
            "id": "5c9490cb00bcfd7eb2be500a",
            "author_id": "5c88bffdacb681372d417bb4",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>多多客（doodooke）是一款支持微信、百度、支付宝小程序的第三方SaaS平台。</p>\n<p><strong>重要更新</strong>\n1、开源diy可视化拖拉拽；\n2、开源taro三端合一小程序；</p>\n<p><strong>3.0 新特性</strong>\n1、支持migrations，可以快速的创建和修改表\n通过命令./bin/migrate.js make [name] --scope [module]创建migration，然后使用./bin/migrate.js latest执行migration，使用./bin/migrate.js rollback回滚migration，具体migration的用法可以参考knex文档 <a href=\"https://knexjs.org\">https://knexjs.org</a></p>\n<p>2、支持rewrite，可以将请求转发到修改过的接口\n二次开发最大的问题就是如何在保证系统一致性和更新的情况下，二次修改代码。比如我们需要修改app模块，然后我们复制app模块，起名apps，然后修改rewrite.js，添加如下数据，即完成了配置。此时我们请求app模块会全部转发到apps模块。提示：一个模块下前端路由不带/api，后端路由以/api开头</p>\n<pre class=\"prettyprint language-js\"><code>module.exports = {\n    &quot;&#x2F;app&quot;: &quot;&#x2F;apps&quot;,\n    &quot;&#x2F;api&#x2F;app&quot;: &quot;&#x2F;api&#x2F;apps&quot;\n}\n</code></pre><p>3、支持view逻辑钩子，可以扩展vue逻辑\n3.0重要的特性之一，可以很方便到扩展vue前端逻辑。通过调用this.$hook.run(“xxx”, 1, 2)自动加载view_hook目录下hook.js名称为xxx的函数，修改data里面的数据等。</p>\n<p>4、支持view视图钩子，可以扩展vue视图\n3.0重要的特性之二，可以很方便的扩展vue前端视图，通过调用&lt;doodoo-hook name=“xxx” abc=“2”&gt;&lt;/doodoo-hook&gt;实现，当系统发现view_hook目录下，名称是xxx.vue会自动加载到调用的位置</p>\n<p>5、支持cluster，可以启动多个项目\n目前仅支持同一个序列号，同一台服务器启动多个实例，如需多台服务器启动，请联系客服</p>\n<p>6、支持本地调试，可以将生产环境的请求转发或复制到本地\n解决生产环境的bug，是一个很头痛的问题，我们除了有错误监控外，新增加了本地调试功能。本地调试功能可以将线上生产环境的请求转发或者复制到本地系统，这样可以快速的发现和修复bug。线上的已全部集成到所有的系统，线下的命令行工具会随后发布。</p>\n<p>7、支持bin命令，可以快速的处理migration等\n目前支持doodoo.sh和migrate.js命令</p>\n<p><a href=\"https://gitee.com/doodooke/doodoo\">3.0开源版</a><a href=\"https://gitee.com/doodooke/doodoo\">https://gitee.com/doodooke/doodoo</a></p>\n</div>",
            "title": "多多客发布 3.0.0-alpha.3开源版，支持微信、百度、支付宝小程序",
            "last_reply_at": "2019-03-22T07:37:47.641Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 73,
            "create_at": "2019-03-22T07:37:47.641Z",
            "author": {
                "loginname": "doodooke1688",
                "avatar_url": "https://avatars0.githubusercontent.com/u/48510722?v=4&s=120"
            }
        }, {
            "id": "5c85c7c5acb681372d416d12",
            "author_id": "58d140302c8bf2a836456213",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><strong>译者按：</strong> JS 骚操作。</p>\n<ul>\n<li>原文：<a href=\"http://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript.html\">For vs forEach() vs for/in vs for/of in JavaScript</a></li>\n<li>译者: <a href=\"https://www.fundebug.com/\">Fundebug</a></li>\n</ul>\n<p><strong>本文采用意译，版权归原作者所有</strong></p>\n<p>我们有多种方法来遍历 JavaScript 的数组或者对象，而它们之间的区别非常让人<a href=\"https://stackoverflow.com/questions/9329446/for-each-over-an-array-in-javascript\">疑惑</a>。<a href=\"http://airbnb.io/javascript/#iterators--nope\">Airbnb 编码风格</a>禁止使用 for/in 与 for/of，你知道为什么吗？</p>\n<p>这篇文章将详细介绍以下 4 种循环语法的区别：</p>\n<ul>\n<li><code>for (let i = 0; i &lt; arr.length; ++i)</code></li>\n<li><code>arr.forEach((v, i) =&gt; { /* ... */ })</code></li>\n<li><code>for (let i in arr)</code></li>\n<li><code>for (const v of arr)</code></li>\n</ul>\n<h3>语法</h3>\n<p>使用<code>for</code>和<code>for/in</code>，我们可以访问数组的下标，而不是实际的数组元素值：</p>\n<pre class=\"prettyprint language-javascript\"><code>for (let i = 0; i &lt; arr.length; ++i) {\n    console.log(arr[i]);\n}\n\nfor (let i in arr) {\n    console.log(arr[i]);\n}\n</code></pre><p>使用<code>for/of</code>，则可以直接访问数组的元素值：</p>\n<pre class=\"prettyprint language-javascript\"><code>for (const v of arr) {\n    console.log(v);\n}\n</code></pre><p>使用<code>forEach()</code>，则可以同时访问数组的下标与元素值：</p>\n<pre class=\"prettyprint language-javascript\"><code>arr.forEach((v, i) =&gt; console.log(v));\n</code></pre><h3>非数字属性</h3>\n<p>JavaScript 的数组就是 Object，这就意味着我们可以给数组添加字符串属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\n\ntypeof arr; &#x2F;&#x2F; &#x27;object&#x27;\n\narr.test = &quot;bad&quot;; &#x2F;&#x2F; 添加非数字属性\n\narr.test; &#x2F;&#x2F; &#x27;abc&#x27;\narr[1] === arr[&quot;1&quot;]; &#x2F;&#x2F; true, JavaScript数组只是特殊的Object\n</code></pre><p>4 种循环语法，只有<code>for/in</code>不会忽略非数字属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\narr.test = &quot;bad&quot;;\n\nfor (let i in arr) {\n    console.log(arr[i]); &#x2F;&#x2F; 打印&quot;a, b, c, bad&quot;\n}\n</code></pre><p>正因为如此，<a href=\"https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-a-bad-idea\">使用<code>for/in</code>遍历数组并不好</a>。</p>\n<p>其他 3 种循环语法，都会忽略非数字属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\narr.test = &quot;abc&quot;;\n\n&#x2F;&#x2F; 打印 &quot;a, b, c&quot;\nfor (let i = 0; i &lt; arr.length; ++i) {\n    console.log(arr[i]);\n}\n\n&#x2F;&#x2F; 打印 &quot;a, b, c&quot;\narr.forEach((el, i) =&gt; console.log(i, el));\n\n&#x2F;&#x2F; 打印 &quot;a, b, c&quot;\nfor (const el of arr) {\n    console.log(el);\n}\n</code></pre><p><strong>要点：</strong> 避免使用<code>for/in</code>来遍历数组，除非你真的要想要遍历非数字属性。可以使用 ESLint 的<a href=\"https://eslint.org/docs/rules/guard-for-in\">guard-for-in</a>规则来禁止使用<code>for/in</code>。</p>\n<h3>数组的空元素</h3>\n<p>JavaScript 数组可以有<a href=\"https://stackoverflow.com/questions/281264/remove-empty-elements-from-an-array-in-javascript\">空元素</a>。以下代码语法是正确的，且数组长度为 3：</p>\n<pre class=\"prettyprint language-javascript\"><code>const arr = [&quot;a&quot;, , &quot;c&quot;];\n\narr.length; &#x2F;&#x2F; 3\n</code></pre><p>让人更加不解的一点是，循环语句处理<code>['a',, 'c']</code>与<code>['a', undefined, 'c']</code>的方式并不相同。</p>\n<p>对于<code>['a',, 'c']</code>，<code>for/in</code>与<code>forEach</code>会跳过空元素，而<code>for</code>与<code>for/of</code>则不会跳过。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 打印&quot;a, undefined, c&quot;\nfor (let i = 0; i &lt; arr.length; ++i) {\n    console.log(arr[i]);\n}\n\n&#x2F;&#x2F; 打印&quot;a, c&quot;\narr.forEach(v =&gt; console.log(v));\n\n&#x2F;&#x2F; 打印&quot;a, c&quot;\nfor (let i in arr) {\n    console.log(arr[i]);\n}\n\n&#x2F;&#x2F; 打印&quot;a, undefined, c&quot;\nfor (const v of arr) {\n    console.log(v);\n}\n</code></pre><p>对于<code>['a', undefined, 'c']</code>，4 种循环语法一致，打印的都是&quot;a, undefined, c&quot;。</p>\n<p>还有一种添加空元素的方式：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 等价于&#96;[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;,, &#x27;e&#x27;]&#96;\nconst arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\narr[5] = &quot;e&quot;;\n</code></pre><p>还有一点，JSON 也不支持空元素：</p>\n<pre class=\"prettyprint language-javascript\"><code>JSON.parse(&#x27;{&quot;arr&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]}&#x27;);\n&#x2F;&#x2F; { arr: [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ] }\n\nJSON.parse(&#x27;{&quot;arr&quot;:[&quot;a&quot;,null,&quot;c&quot;]}&#x27;);\n&#x2F;&#x2F; { arr: [ &#x27;a&#x27;, null, &#x27;c&#x27; ] }\n\nJSON.parse(&#x27;{&quot;arr&quot;:[&quot;a&quot;,,&quot;c&quot;]}&#x27;);\n&#x2F;&#x2F; SyntaxError: Unexpected token , in JSON at position 12\n</code></pre><p><strong>要点：</strong> <code>for/in</code>与<code>forEach</code>会跳过空元素，数组中的空元素被称为<a href=\"http://2ality.com/2013/07/array-iteration-holes.html\">&quot;holes&quot;</a>。如果你想避免这个问题，可以考虑禁用<code>forEach</code>:</p>\n<pre class=\"prettyprint language-yml\"><code>parserOptions:\n    ecmaVersion: 2018\nrules:\n    no-restricted-syntax:\n        - error\n        - selector: CallExpression[callee.property.name=&quot;forEach&quot;]\n          message: Do not use &#96;forEach()&#96;, use &#96;for&#x2F;of&#96; instead\n</code></pre><h3>函数的 this</h3>\n<p><code>for</code>，<code>for/in</code>与<code>for/of</code>会保留外部作用域的<code>this</code>。</p>\n<p>对于<code>forEach</code>， 除非使用箭头函数，它的回调函数的 this 将会变化。</p>\n<p>使用 Node v11.8.0 测试下面的代码，结果如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&quot;use strict&quot;;\n\nconst arr = [&quot;a&quot;];\n\narr.forEach(function() {\n    console.log(this); &#x2F;&#x2F; 打印undefined\n});\n\narr.forEach(() =&gt; {\n    console.log(this); &#x2F;&#x2F; 打印{}\n});\n</code></pre><p><strong>要点：</strong> 使用 ESLint 的<a href=\"https://eslint.org/docs/rules/prefer-arrow-callback\"><code>no-arrow-callback</code></a>规则要求所有回调函数必须使用箭头函数。</p>\n<h3>Async/Await 与 Generators</h3>\n<p>还有一点，<code>forEach()</code>不能与 Async/Await 及 Generators 很好的&quot;合作&quot;。</p>\n<p>不能在<code>forEach</code>回调函数中使用 await：</p>\n<pre class=\"prettyprint language-javascript\"><code>async function run() {\n  const arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];\n  arr.forEach(el =&gt; {\n    &#x2F;&#x2F; SyntaxError\n    await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n    console.log(el);\n  });\n}\n</code></pre><p>不能在<code>forEach</code>回调函数中使用 yield：</p>\n<pre class=\"prettyprint language-javascript\"><code>function run() {\n  const arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];\n  arr.forEach(el =&gt; {\n    &#x2F;&#x2F; SyntaxError\n    yield new Promise(resolve =&gt; setTimeout(resolve, 1000));\n    console.log(el);\n  });\n}\n</code></pre><p>对于<code>for/of</code>来说，则没有这个问题:</p>\n<pre class=\"prettyprint language-javascript\"><code>async function asyncFn() {\n    const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\n    for (const el of arr) {\n        await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n        console.log(el);\n    }\n}\n\nfunction* generatorFn() {\n    const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\n    for (const el of arr) {\n        yield new Promise(resolve =&gt; setTimeout(resolve, 1000));\n        console.log(el);\n    }\n}\n</code></pre><p>当然，你如果将<code>forEach()</code>的回调函数定义为 async 函数就不会报错了，但是，如果你想让<code>forEach</code><a href=\"https://thecodebarbarian.com/basic-functional-programming-with-async-await.html\">按照顺序执行</a>，则会比较头疼。</p>\n<p>下面的代码会按照从大到小打印 0-9：</p>\n<pre class=\"prettyprint language-javascript\"><code>async function print(n) {\n    &#x2F;&#x2F; 打印0之前等待1秒，打印1之前等待0.9秒\n    await new Promise(resolve =&gt; setTimeout(() =&gt; resolve(), 1000 - n * 100));\n    console.log(n);\n}\n\nasync function test() {\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].forEach(print);\n}\n\ntest();\n</code></pre><p><strong>要点：</strong> 尽量不要在<code>forEach</code>中使用 aysnc/await 以及 generators。</p>\n<h3>结论</h3>\n<p>简单地说，<code>for/of</code>是遍历数组最可靠的方式，它比<code>for</code>循环简洁，并且没有<code>for/in</code>和<code>forEach()</code>那么多奇怪的特例。<code>for/of</code>的缺点是我们取索引值不方便，而且不能这样链式调用<code>forEach()</code>. <code>forEach()</code>。</p>\n<p>使用<code>for/of</code>获取数组索引，可以这样写：</p>\n<pre class=\"prettyprint language-javascript\"><code>for (const [i, v] of arr.entries()) {\n    console.log(i, v);\n}\n</code></pre><h3>参考</h3>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/9329446/for-each-over-an-array-in-javascript\">For-each over an array in JavaScript?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-a-bad-idea\">Why is using “for…in” with array iteration a bad idea?</a></li>\n<li><a href=\"http://2ality.com/2013/07/array-iteration-holes.html\">Array iteration and holes in JavaScript</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2019/03/11/4-ways-to-loop-array-inj-javascript/\">https://blog.fundebug.com/2019/03/11/4-ways-to-loop-array-inj-javascript/</a></p>\n</div>",
            "title": "JavaScript 的 4 种数组遍历方法： for VS forEach() VS for/in VS for/of",
            "last_reply_at": "2019-03-22T07:34:36.771Z",
            "good": false,
            "top": false,
            "reply_count": 4,
            "visit_count": 589,
            "create_at": "2019-03-11T02:28:21.879Z",
            "author": {
                "loginname": "Fundebug",
                "avatar_url": "https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"
            }
        }, {
            "id": "5c94839700bcfd7eb2be4f4f",
            "author_id": "5732e4852e11c7a80c33f8aa",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>nodejs服务需要不断的定期发送request请求，那么UV_THREADPOOL_SIZE设置为多少比较合适？对服务性能有什么影响，有没有实际操作过的？麻烦帮忙解答一下。</p>\n</div>",
            "title": "对于大并发请求的node服务，调整UV_THREADPOOL_SIZE到多大比较合适？",
            "last_reply_at": "2019-03-22T07:06:44.093Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 97,
            "create_at": "2019-03-22T06:41:27.976Z",
            "author": {
                "loginname": "evershy",
                "avatar_url": "https://avatars2.githubusercontent.com/u/9037313?v=4&s=120"
            }
        }, {
            "id": "5a9317d38d6e16e56bb808d1",
            "author_id": "5909444b782dbc4b183ecfe2",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>也就前两天，面试大厂，其中有那么一个问题:</p>\n<ol>\n<li>你了解过Babel吗？</li>\n</ol>\n<blockquote>\n<p>了解过抽象语法树，又称AST，有学习过，也写过一个基于AST的<a href=\"https://github.com/axetroy/pag\">乞丐版模板引擎</a>，先是词法解析token，然后生产抽象语法树，然后更改抽象语法树，当然这是插件做的事情，最后根据新的AST生成代码。</p>\n</blockquote>\n<ol>\n<li>写过Babel插件吗</li>\n</ol>\n<blockquote>\n<p>没有，只是看过相关文档</p>\n</blockquote>\n<ol>\n<li>如果让你写一个插件，你能写的出来吗?</li>\n</ol>\n<blockquote>\n<p>应该可以吧…</p>\n</blockquote>\n<p>遂卒…</p>\n<p>开玩笑的，既然提到了，又没回答上来什么，哎哟我这暴脾气，一想到今晚就睡不着，连夜把它撸了。</p>\n<p>那么我们来从零写个插件吧。</p>\n<p>写一个预计算简单表达式的插件</p>\n<h3>预览</h3>\n<p>Before:</p>\n<pre class=\"prettyprint language-javascript\"><code>const result = 1 + 2 + 3 + 4 + 5;\n</code></pre><p>After:</p>\n<pre class=\"prettyprint language-javascript\"><code>const result = 15;\n</code></pre><p>以上的例子可能大家不会经常遇到，因为傻x才会这么写，但是有可能你会这么写</p>\n<pre class=\"prettyprint language-javascript\"><code>setTimeout(function(){\n  &#x2F;&#x2F; do something\n}, 1000 * 2) &#x2F;&#x2F; 插件要做的事，就是把 1000 * 2 替换成 2000\n</code></pre><h3>前提条件</h3>\n<ul>\n<li><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md\">Babel相关概念</a></li>\n</ul>\n<h3>开工</h3>\n<p>再写代码之前，你需要明白Babel它的原理，简单点说： <strong>Babel解析成AST，然后插件更改AST，最后由Babel输出代码</strong></p>\n<p>那么Babel的插件模块需要你暴露一个function，function内返回visitor</p>\n<pre class=\"prettyprint language-javascript\"><code>module.export = function(babel){\n  return {\n    visitor:{\n    }\n  }\n}\n</code></pre><p>visitor是对各类型的AST节点做处理的地方，那么我们怎么知道Babel生成了的AST有哪些节点呢？</p>\n<p>很简单，你可以把Babel转换的结果打印出来，或者这里有传送门: <a href=\"https://astexplorer.net/\">AST explorer</a></p>\n<p><img src=\"https://user-images.githubusercontent.com/9758711/36645536-6165e5c2-1aa5-11e8-8bd1-fad3e2080658.JPG\" alt=\"1\"></p>\n<p>这里我们看到 <code>const result = 1 + 2</code>中的<code>1 + 1</code>是一个<code>BinaryExpression</code>节点，那么在visitor中，我们就处理这个节点</p>\n<pre class=\"prettyprint language-javascript\"><code>var babel = require(&#x27;babel-core&#x27;);\nvar t = require(&#x27;babel-types&#x27;);\n\nconst visitor = {\n  BinaryExpression(path) {\n    const node = path.node;\n    let result;\n    &#x2F;&#x2F; 判断表达式两边，是否都是数字\n    if (t.isNumericLiteral(node.left) &amp;&amp; t.isNumericLiteral(node.right)) {\n      &#x2F;&#x2F; 根据不同的操作符作运算\n      switch (node.operator) {\n        case &quot;+&quot;:\n          result = node.left.value + node.right.value;\n          break\n        case &quot;-&quot;:\n          result = node.left.value - node.right.value;\n          break;\n        case &quot;*&quot;:\n          result =  node.left.value * node.right.value;\n          break;\n        case &quot;&#x2F;&quot;:\n          result =  node.left.value &#x2F; node.right.value;\n          break;\n        case &quot;**&quot;:\n          let i = node.right.value;\n          while (--i) {\n            result = result || node.left.value;\n            result =  result * node.left.value;\n          }\n          break;\n        default:\n      }\n    }\n\n    &#x2F;&#x2F; 如果上面的运算有结果的话\n    if (result !== undefined) {\n      &#x2F;&#x2F; 把表达式节点替换成number字面量\n      path.replaceWith(t.numericLiteral(result));\n    }\n  }\n};\n\nmodule.exports = function (babel) {\n  return {\n    visitor\n  };\n}\n</code></pre><p>插件写好了，我们运行下插件试试</p>\n<pre class=\"prettyprint language-javascript\"><code>const babel = require(&quot;babel-core&quot;);\n\nconst result = babel.transform(&quot;const result = 1 + 2;&quot;,{\n  plugins:[\n    require(&quot;.&#x2F;index&quot;)\n  ]\n});\n\nconsole.log(result.code); &#x2F;&#x2F; const result = 3;\n</code></pre><p>与预期一致，那么转换 <code>const result = 1 + 2 + 3 + 4 + 5;</code>呢?</p>\n<p>结果是: <code>const result = 3 + 3 + 4 + 5;</code></p>\n<p>这就奇怪了，为什么只计算了<code>1 + 2</code>之后，就没有继续往下运算了?</p>\n<p>我们看一下这个表达式的AST树</p>\n<p><img src=\"https://user-images.githubusercontent.com/9758711/36645660-2bdd028a-1aa7-11e8-9131-c38c232ccb10.JPG\" alt=\"2\"></p>\n<p>你会发现Babel解析成表达式里面再嵌套表达式。</p>\n<pre class=\"prettyprint\"><code>表达式( 表达式( 表达式( 表达式(1 + 2) + 3) + 4) + 5)\n</code></pre><p>而我们的判断条件并不符合所有的，只符合<code>1 + 2</code></p>\n<pre class=\"prettyprint language-javascript\"><code>    &#x2F;&#x2F; 判断表达式两边，是否都是数字\n    if (t.isNumericLiteral(node.left) &amp;&amp; t.isNumericLiteral(node.right)) {}\n</code></pre><p>那么我们得改一改</p>\n<p>第一次计算<code>1 + 2</code>之后，我们会得到这样的表达式</p>\n<pre class=\"prettyprint\"><code>表达式( 表达式( 表达式(3 + 3) + 4) + 5)\n</code></pre><p>其中 <code>3 + 3</code>又符合了我们的条件， 我们通过向上递归的方式遍历父级节点</p>\n<p>又转换成这样:</p>\n<pre class=\"prettyprint\"><code>表达式( 表达式(6 + 4) + 5)\n表达式(10 + 5)\n15\n</code></pre><pre class=\"prettyprint language-javascript\"><code>    &#x2F;&#x2F; 如果上面的运算有结果的话\n    if (result !== undefined) {\n      &#x2F;&#x2F; 把表达式节点替换成number字面量\n      path.replaceWith(t.numericLiteral(result));\n\n      let parentPath = path.parentPath;\n\n      &#x2F;&#x2F; 向上遍历父级节点\n      parentPath &amp;&amp; visitor.BinaryExpression.call(this, parentPath);\n    }\n</code></pre><p>到这里，我们就得出了结果 <code>const result = 15;</code></p>\n<p>那么其他运算呢:</p>\n<p><code>const result = 100 + 10 - 50</code> &gt;&gt;&gt; <code>const result = 60;</code></p>\n<p><code>const result = (100 / 2) + 50</code> &gt;&gt;&gt; <code>const result = 100;</code></p>\n<p><code>const result = (((100 / 2) + 50 * 2) / 50) ** 2</code> &gt;&gt;&gt; <code>const result = 9;</code></p>\n<h3>完结</h3>\n<p>到这里，已经向你大概的讲解了，如何编写一个Babel插件，再也不怕面试官问我答不出什么了哈…</p>\n<p>你以为这就完了吗?</p>\n<p>并没有</p>\n<p>如果转换这样呢: <code>const result = 0.1 + 0.2;</code></p>\n<p>预期肯定是<code>0.3</code>, 但是实际上，Javascript有浮点计算误差，得出的结果是<code>0.30000000000000004</code></p>\n<p>那是不是这个插件就没卵用？</p>\n<p>这就需要你去矫正浮点运算误差了，可以使用<a href=\"https://github.com/MikeMcl/big.js\">Big.js</a>;</p>\n<p>比如: <code>result = node.left.value + node.right.value;</code> 改成 <code>result = +new Big(node.left.value).plus(node.right.value);</code></p>\n<p>你以为完了吗? 这个插件还可以做很多</p>\n<p>比如: <code>Math.PI * 2</code> &gt;&gt;&gt; <code>6.283185307179586</code></p>\n<p>比如: <code>Math.pow(2, 2)</code> &gt;&gt;&gt; <code>4</code></p>\n<p>…</p>\n<p>…</p>\n<p>最后上项目地址: <a href=\"https://github.com/axetroy/babel-plugin-pre-calculate-number\">https://github.com/axetroy/babel-plugin-pre-calculate-number</a></p>\n</div>",
            "title": "面试官: 你了解过Babel吗？写过Babel插件吗? 答: 没有。卒",
            "last_reply_at": "2019-03-22T06:47:52.610Z",
            "good": true,
            "top": false,
            "reply_count": 52,
            "visit_count": 10252,
            "create_at": "2018-02-25T20:08:51.322Z",
            "author": {
                "loginname": "axetroy",
                "avatar_url": "https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"
            }
        }, {
            "id": "5c943f1afd41137eb7660584",
            "author_id": "58058ff1487e1e4578afb5c2",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>大家有没有发现，有的时候题目，比题目本身更难，经常读不懂题目，应该是我英文太差了吧</p>\n</div>",
            "title": "关于leetcode",
            "last_reply_at": "2019-03-22T03:25:42.759Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 185,
            "create_at": "2019-03-22T01:49:14.918Z",
            "author": {
                "loginname": "luanxuechao",
                "avatar_url": "https://avatars1.githubusercontent.com/u/13465762?v=4&s=120"
            }
        }, {
            "id": "5c92e30b96558e26e1b67efb",
            "author_id": "58d140302c8bf2a836456213",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><ul>\n<li>GitHub 仓库：<a href=\"https://github.com/Fundebug/loop-mongodb-big-collection\">Fundebug/loop-mongodb-big-collection</a></li>\n</ul>\n<p><img src=\"https://image.fundebug.com/2019-03-21-mongodb.jpg\" alt></p>\n<p>本文使用的编程语言是 Node.js，连接 MongoDB 的模块用的是<a href=\"https://mongoosejs.com/\">mongoose</a>。但是，本文介绍的方法适用于其他编程语言及其对应的 MongoDB 模块。</p>\n<h3>错误方法：find()</h3>\n<p>也许，在遍历 MongoDB 集合时，我们会这样写：</p>\n<pre class=\"prettyprint language-javascript\"><code>const Promise = require(&quot;bluebird&quot;);\n\nfunction findAllMembers() {\n    return Member.find();\n}\n\nasync function test() {\n    const members = await findAllMembers();\n    let N = 0;\n    await Promise.mapSeries(members, member =&gt; {\n        N++;\n        console.log(&#96;name of the ${N}th member: ${member.name}&#96;);\n    });\n    console.log(&#96;loop all ${N} members success&#96;);\n}\n\ntest();\n</code></pre><p>注意，我们使用的是 Bluebird 的<a href=\"http://bluebirdjs.com/docs/api/promise.mapseries.html\">mapSeries</a>而非<a href=\"http://bluebirdjs.com/docs/api/promise.map.html\">map</a>，members 数组中的元素是一个一个处理的。这样就够了吗？</p>\n<p>当 Member 集合中的 document 不多时，比如只有 1000 个时，那确实没有问题。但是当 Member 集合中有 1000 万个 document 时，会发生什么呢？如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&lt;--- Last few GCs ---&gt;\nrt of marking 1770 ms) (average mu = 0.168, current mu = 0.025) finalize [5887:0x43127d0]    33672 ms: Mark-sweep 1398.3 (1425.2) -&gt; 1398.0 (1425.7) MB, 1772.0 &#x2F; 0.0 ms  (+ 0.1 ms in 12 steps since start of marking, biggest step 0.0 ms, walltime since start of marking 1775 ms) (average mu = 0.088, current mu = 0.002) finalize [5887:0x43127d0]    35172 ms: Mark-sweep 1398.5 (1425.7) -&gt; 1398.4 (1428.7) MB, 1496.7 &#x2F; 0.0 ms  (average mu = 0.049, current mu = 0.002) allocation failure scavenge might not succeed\n\n\n&lt;--- JS stacktrace ---&gt;\n\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\n 1: 0x8c02c0 node::Abort() [node]\n 2: 0x8c030c  [node]\n 3: 0xad15de v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [node]\n 4: 0xad1814 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [node]\n 5: 0xebe752  [node]\n 6: 0xebe858 v8::internal::Heap::CheckIneffectiveMarkCompact(unsigned long, double) [node]\n 7: 0xeca982 v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [node]\n 8: 0xecb2b4 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [node]\n 9: 0xecba8a v8::internal::Heap::FinalizeIncrementalMarkingIfComplete(v8::internal::GarbageCollectionReason) [node]\n10: 0xecf1b7 v8::internal::IncrementalMarkingJob::Task::RunInternal() [node]\n11: 0xbc1796 v8::internal::CancelableTask::Run() [node]\n12: 0x935018 node::PerIsolatePlatformData::FlushForegroundTasksInternal() [node]\n13: 0x9fccff  [node]\n14: 0xa0dbd8  [node]\n15: 0x9fd63b uv_run [node]\n16: 0x8ca6c5 node::Start(v8::Isolate*, node::IsolateData*, int, char const* const*, int, char const* const*) [node]\n17: 0x8c945f node::Start(int, char**) [node]\n18: 0x7f84b6263f45 __libc_start_main [&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6]\n19: 0x885c55  [node]\nAborted (core dumped)\n</code></pre><p>可知，内存不足了。</p>\n<p>打印<a href=\"https://mongoosejs.com/docs/api.html#model_Model.find\">find()</a>返回的 members 数组可知，集合中所有元素都返回了，<strong>哪个数组放得下 1000 万个 Object?</strong></p>\n<h3>正确方法：find().cursor()与 eachAsync()</h3>\n<p>将整个集合 find()全部返回，这种操作应该避免，正确的方法应该是这样的：</p>\n<pre class=\"prettyprint language-javascript\"><code>function findAllMembersCursor() {\n    return Member.find().cursor();\n}\n\nasync function test() {\n    const membersCursor = await findAllMembersCursor();\n    let N = 0;\n    await membersCursor.eachAsync(member =&gt; {\n        N++;\n        console.log(&#96;name of the ${N}th member: ${member.name}&#96;);\n    });\n    console.log(&#96;loop all ${N} members success&#96;);\n}\n\ntest();\n</code></pre><p>使用<a href=\"https://mongoosejs.com/docs/api.html#query_Query-cursor\">cursor()</a>方法返回 QueryCursor，然后再使用<a href=\"https://mongoosejs.com/docs/api.html#querycursor_QueryCursor-eachAsync\">eachAsync()</a>就可以遍历整个集合了，而且不用担心内存不够。</p>\n<p><a href=\"https://mongoosejs.com/docs/api.html#QueryCursor\">QueryCursor</a>是什么呢？不妨看一下 mongoose 文档：</p>\n<blockquote>\n<p>A QueryCursor is a concurrency primitive for processing query results one document at a time. A QueryCursor fulfills the Node.js streams3 API, in addition to several other mechanisms for loading documents from MongoDB one at a time.</p>\n</blockquote>\n<p>总之，QueryCursor 可以每次从 MongoDB 中取一个 document，这样显然极大地减少了内存使用。</p>\n<h3>如何测试？</h3>\n<p>这篇博客介绍的内容很简单，但是也很容易被忽视。如果大家测试一下，印象会更加深刻一些。</p>\n<p>测试代码很简单，大家可以查看<a href=\"https://github.com/Fundebug/loop-mongodb-big-collection\">Fundebug/loop-mongodb-big-collection</a>。</p>\n<p>我的测试环境是这样的：</p>\n<ul>\n<li>ubuntu 14.04</li>\n<li>mongodb 3.2</li>\n<li>nodejs 10.9.0</li>\n</ul>\n<p><strong>1. 使用 Docker 运行 MongoDB</strong></p>\n<pre class=\"prettyprint language-bash\"><code>sudo docker run --net=host -d --name mongodb daocloud.io&#x2F;library&#x2F;mongo:3.2\n</code></pre><p><strong>2. 使用<a href=\"https://github.com/feliixx/mgodatagen\">mgodatagen</a>生成测试数据</strong></p>\n<p>使用 mgodatagen，1000 万个 document 可以在 1 分多钟生成！</p>\n<p>下载 mgodatagen：<a href=\"https://github.com/feliixx/mgodatagen/releases/download/0.7.3/mgodatagen_linux_x86_64.tar.gz\">https://github.com/feliixx/mgodatagen/releases/download/0.7.3/mgodatagen_linux_x86_64.tar.gz</a></p>\n<p>解压之后，复制到/usr/local/bin 目录即可：</p>\n<pre class=\"prettyprint language-bash\"><code>sudo mv mgodatagen &#x2F;usr&#x2F;local&#x2F;bin\n</code></pre><p>mgodatagen 的配置文件<a href=\"https://github.com/Fundebug/loop-mongodb-big-collection/blob/master/mgodatagen-config.json\">mgodatagen-config.json</a>如下：</p>\n<pre class=\"prettyprint language-json\"><code>[\n    {\n        &quot;database&quot;: &quot;test&quot;,\n        &quot;collection&quot;: &quot;members&quot;,\n        &quot;count&quot;: 10000000,\n        &quot;content&quot;: {\n            &quot;name&quot;: {\n                &quot;type&quot;: &quot;string&quot;,\n                &quot;minLength&quot;: 2,\n                &quot;maxLength&quot;: 8\n            },\n            &quot;city&quot;: {\n                &quot;type&quot;: &quot;string&quot;,\n                &quot;minLength&quot;: 2,\n                &quot;maxLength&quot;: 8\n            },\n            &quot;country&quot;: {\n                &quot;type&quot;: &quot;string&quot;,\n                &quot;minLength&quot;: 2,\n                &quot;maxLength&quot;: 8\n            },\n            &quot;company&quot;: {\n                &quot;type&quot;: &quot;string&quot;,\n                &quot;minLength&quot;: 2,\n                &quot;maxLength&quot;: 8\n            },\n            &quot;email&quot;: {\n                &quot;type&quot;: &quot;string&quot;,\n                &quot;minLength&quot;: 2,\n                &quot;maxLength&quot;: 8\n            }\n        }\n    }\n]\n</code></pre><p>执行<code>mgodatagen -f mgodatagen-config.json</code>命令，即可生成 10000 万测试数据。</p>\n<pre class=\"prettyprint language-bash\"><code>mgodatagen -f mgodatagen-config.json\nConnecting to mongodb:&#x2F;&#x2F;127.0.0.1:27017\nMongoDB server version 3.2.13\n\ncollection members: done            [====================================================================] 100%\n\n+------------+----------+-----------------+----------------+\n| COLLECTION |  COUNT   | AVG OBJECT SIZE |    INDEXES     |\n+------------+----------+-----------------+----------------+\n| members    | 10000000 |             108 | _id_  95368 kB |\n+------------+----------+-----------------+----------------+\n\nrun finished in 1m12.82s\n</code></pre><p>查看 MongoDB，可知新生成的数据有 0.69GB，其实很小，但是使用 find()方法遍历会报错。</p>\n<pre class=\"prettyprint language-bash\"><code>show dbs\nlocal  0.000GB\ntest   0.690GB\n</code></pre><p><strong>3. 执行测试代码</strong></p>\n<p>两种不同遍历方法的代码分别位于<a href=\"https://github.com/Fundebug/loop-mongodb-big-collection/blob/master/test1.js\">test1.js</a>和<a href=\"https://github.com/Fundebug/loop-mongodb-big-collection/blob/master/test2.js\">test2.js</a>。</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://cnodejs.org/topic/51508570604b3d512113f1b3\">如何使用 mongoose 对一个 100 万+的 mongodb 的表进行遍历操作</a></li>\n<li><a href=\"https://thecodebarbarian.com/cursors-in-mongoose-45\">Cursors in Mongoose 4.5</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2019/03/21/how-to-visit-all-documents-in-a-big-collection-of-mongodb/\">https://blog.fundebug.com/2019/03/21/how-to-visit-all-documents-in-a-big-collection-of-mongodb/</a></p>\n</div>",
            "title": "如何高效地遍历 MongoDB 超大集合？",
            "last_reply_at": "2019-03-22T03:20:06.343Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 282,
            "create_at": "2019-03-21T01:04:11.264Z",
            "author": {
                "loginname": "Fundebug",
                "avatar_url": "https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"
            }
        }, {
            "id": "5befe1b1be1b120abac5a592",
            "author_id": "5b5a7729b71aedfe4c12652b",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>6套经典node.js+vue项目实战视频教程，大家看看下面具体教程，有需要的可以学习一下哦</p>\n<p><img src=\"//static.cnodejs.org/FisDxxcRtOtl7qWtIwYMfYzDTr2G\" alt=\"11111.jpg\"></p>\n<p><strong>教程如下：</strong>\n[node]7天搞定NodeJS微信公众号开发\n[vue]vue2.0+node.js+MongoDB全栈打造商城（新录制）\nVue+Node+MongoDB小程序公众号全栈项目开发实战\nnode.js从入门到实战教育项目\nVue+Node+MongoDB小程序公众号全栈项目开发实战\n【实战】Node.js + Web Socket 打造即时通讯聊天程序</p>\n<p>下载地址：<a href=\"http://www.sucaihuo.com/video/378.html\">http://www.sucaihuo.com/video/378.html</a></p>\n</div>",
            "title": "6套经典node.js+vue项目实战视频教程",
            "last_reply_at": "2019-03-22T02:01:38.434Z",
            "good": false,
            "top": false,
            "reply_count": 17,
            "visit_count": 3313,
            "create_at": "2018-11-17T09:38:57.164Z",
            "author": {
                "loginname": "codeofking",
                "avatar_url": "https://avatars2.githubusercontent.com/u/41748064?v=4&s=120"
            }
        }, {
            "id": "5c942d8500bcfd7eb2be4ca7",
            "author_id": "5a0a5c9da57c17282e120654",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/22/169a2cd15dff8805?w=800&amp;h=530&amp;f=png&amp;s=508261\" alt=\"20190322082820.png\"></p>\n<h1>[译]使用 JavaScript 对象 Rest 和 Spread 的7个技巧</h1>\n<ul>\n<li>原文作者：Joel Thoms</li>\n<li>原文标题：7 Tricks with Resting and Spreading JavaScript Objects</li>\n<li>原文：<a href=\"https://blog.bitsrc.io/6-tricks-with-resting-and-spreading-javascript-objects-68d585bdc83\">https://blog.bitsrc.io/6-tricks-with-resting-and-spreading-javascript-objects-68d585bdc83</a></li>\n</ul>\n<p>Rest 和 Spread 操作符不仅仅可以用于让参数休息和扩展数组。</p>\n<p>下面针对 JavaScript 对象时使用 Rest 和 Spread 时的 7 个鲜为人知的技巧。</p>\n<h2>添加属性</h2>\n<p>克隆一个对象，同时向(浅)克隆对象添加附加属性。</p>\n<p>在这个示例中，user 被克隆，password 属性被添加到 userWithPass 中。</p>\n<pre class=\"prettyprint language-js\"><code>const user = { id: 100, name: &#x27;Howard Moon&#x27;}\nconst userWithPass = { ...user, password: &#x27;Password!&#x27; }\n\nuser &#x2F;&#x2F;=&gt; { id: 100, name: &#x27;Howard Moon&#x27; }\nuserWithPass &#x2F;&#x2F;=&gt; { id: 100, name: &#x27;Howard Moon&#x27;, password: &#x27;Password!&#x27; }\n</code></pre><h2>对象合并</h2>\n<p>将两个对象合并到一个新对象中。</p>\n<p>将 Part1 和 Part2 合并到 user1中。</p>\n<pre class=\"prettyprint language-js\"><code>const part1 = { id: 100, name: &#x27;Howard Moon&#x27; }\nconst part2 = { id: 100, password: &#x27;Password!&#x27; }\n\nconst user1 = { ...part1, ...part2 }\n&#x2F;&#x2F;=&gt; { id: 100, name: &#x27;Howard Moon&#x27;, password: &#x27;Password!&#x27; }\n</code></pre><p>对象也可以使用以下语法合并:</p>\n<pre class=\"prettyprint language-js\"><code>const partial = { id: 100, name: &#x27;Howard Moon&#x27; }\nconst user = { ...partial, id: 100, password: &#x27;Password!&#x27; }\n\nuser &#x2F;&#x2F;=&gt; { id: 100, name: &#x27;Howard Moon&#x27;, password: &#x27;Password!&#x27; }\n</code></pre><h2>排除对象属性</h2>\n<p>可以结合使用解构 rest 运算符删除属性。 在这里，password 被删除 ，其余的属性作为 rest 返回。</p>\n<pre class=\"prettyprint language-js\"><code>const noPassword = ({ password, ...rest }) =&gt; rest\nconst user = {\n  id: 100,\n  name: &#x27;Howard Moon&#x27;,\n  password: &#x27;Password!&#x27;\n}\n\nnoPassword(user) &#x2F;&#x2F;=&gt; { id: 100, name: &#x27;Howard moon&#x27; }\n</code></pre><h2>动态排除属性</h2>\n<p>函数接受一个 prop 作为参数。使用计算对象属性名称，可以从克隆中动态地删除属性。</p>\n<pre class=\"prettyprint language-js\"><code>const user1 = {\n  id: 100,\n  name: &#x27;Howard Moon&#x27;,\n  password: &#x27;Password!&#x27;\n}\nconst removeProperty = prop =&gt; ({ [prop]: _, ...rest }) =&gt; rest\n&#x2F;&#x2F;                     ----       ------\n&#x2F;&#x2F;                          \\   &#x2F;\n&#x2F;&#x2F;                dynamic destructuring\n\nconst removePassword = removeProperty(&#x27;password&#x27;)\nconst removeId = removeProperty(&#x27;id&#x27;)\n\nremovePassword(user1) &#x2F;&#x2F;=&gt; { id: 100, name: &#x27;Howard Moon&#x27; }\nremoveId(user1) &#x2F;&#x2F;=&gt; { name: &#x27;Howard Moon&#x27;, password: &#x27;Password!&#x27; }\n</code></pre><h2>对属性进行排序</h2>\n<p>有时性质并不按照我们需要的顺序排列。 使用一些技巧，我们可以将属性推到列表的顶部，或者将它们移到底部。</p>\n<p>若要将 id 移动到第一个位置，在扩展对象之前将 <code>id: undefined</code> 添加到新的 Object 最前面。</p>\n<pre class=\"prettyprint language-js\"><code>const user3 = {\n  password: &#x27;Password!&#x27;,\n  name: &#x27;Naboo&#x27;,\n  id: 300\n}\n\nconst organize = object =&gt; ({ id: undefined, ...object })\n&#x2F;&#x2F;                            -------------\n&#x2F;&#x2F;                          &#x2F;\n&#x2F;&#x2F;  move id to the first property\n\norganize(user3)\n&#x2F;&#x2F;=&gt; { id: 300, password: &#x27;Password!&#x27;, name: &#x27;Naboo&#x27; }\n</code></pre><p>若要将 password 移到最后一个属性，请从对象中解构 password。然后在使用 Rest 操作符后重新设置 password 属性。</p>\n<pre class=\"prettyprint language-js\"><code>const user3 = {\n  password: &#x27;Password!&#x27;,\n  name: &#x27;Naboo&#x27;,\n  id: 300\n}\n\nconst organize = ({ password, ...object }) =&gt;\n  ({ ...object, password })\n&#x2F;&#x2F;              --------\n&#x2F;&#x2F;             &#x2F;\n&#x2F;&#x2F; move password to last property\n\norganize(user3)\n&#x2F;&#x2F;=&gt; { name: &#x27;Naboo&#x27;, id: 300, password: &#x27;Password!&#x27; }\n</code></pre><h2>默认属性</h2>\n<p>默认属性是仅当它们不包含在原始对象中时才设置的值。</p>\n<p>在本例中，user2 不包含 quotes 属性。 setdefaults 函数确保所有对象都设置了 quotes 属性，否则它将被设置为<code>[]</code>。</p>\n<p>当调用 setDefaults (user2)时，返回值将包含 quotes 属性: <code>[]</code>。</p>\n<p>在调用 setDefaults (user4)时，因为 user4 已经有了 quotes 属性，所以不会修改该属性。</p>\n<pre class=\"prettyprint language-js\"><code>const user2 = {\n  id: 200,\n  name: &#x27;Vince Noir&#x27;\n}\n\nconst user4 = {\n  id: 400,\n  name: &#x27;Bollo&#x27;,\n  quotes: [&quot;I&#x27;ve got a bad feeling about this...&quot;]\n}\n\nconst setDefaults = ({ quotes = [], ...object}) =&gt;\n  ({ ...object, quotes })\n\nsetDefaults(user2)\n&#x2F;&#x2F;=&gt; { id: 200, name: &#x27;Vince Noir&#x27;, quotes: [] }\n\nsetDefaults(user4)\n&#x2F;&#x2F;=&gt; {\n&#x2F;&#x2F;=&gt;   id: 400,\n&#x2F;&#x2F;=&gt;   name: &#x27;Bollo&#x27;,\n&#x2F;&#x2F;=&gt;   quotes: [&quot;I&#x27;ve got a bad feeling about this...&quot;]\n&#x2F;&#x2F;=&gt; }\n</code></pre><p>如果你希望默认值先出现而不是后出现，也可以这样写:</p>\n<pre class=\"prettyprint language-js\"><code>const setDefaults = ({ ...object}) =&gt; ({ quotes: [], ...object })\n</code></pre><h2>属性重命名</h2>\n<p>通过结合上面的技术，可以创建一个函数来重命名属性。</p>\n<p>假设有一些大写 ID 的对象属性名应该是小写的 id。 首先从对象解构 ID 然后在对象 Spread 时将其作为 id 添加回去。</p>\n<pre class=\"prettyprint language-js\"><code>const renamed = ({ ID, ...object }) =&gt; ({ id: ID, ...object })\n\nconst user = {\n  ID: 500,\n  name: &quot;Bob Fossil&quot;\n}\n\nrenamed(user) &#x2F;&#x2F;=&gt; { id: 500, name: &#x27;Bob Fossil&#x27; }\n</code></pre><h2>附赠：添加条件属性</h2>\n<p>感谢 <code>@vinialbano</code> 指出你也可以有条件地添加属性。 在这个例子中，只有当 password 是真实的时候才会添加 password！</p>\n<pre class=\"prettyprint language-js\"><code>const user = { id: 100, name: &#x27;Howard Moon&#x27; }\nconst password = &#x27;Password!&#x27;\nconst userWithPassword = {\n  ...user,\n  id: 100,\n  ...(password &amp;&amp; { password })\n}\n\nuserWithPassword &#x2F;&#x2F;=&gt; { id: 100, name: &#x27;Howard Moon&#x27;, password: &#x27;Password!&#x27; }\n</code></pre><h2>摘要</h2>\n<p>我试着列出了一些鲜为人知的 Spread 和 Rest 技巧，如果你知道任何我没有列在这里技巧，请在评论区里让每个人都知道！如果你从中学到了新的东西，请在 Twitter 上和你的朋友分享，这真的很有帮助！</p>\n<p>请在这里或者推特 <a href=\"/user/joelnet\">@joelnet</a> 关注我！\n<img src=\"https://user-gold-cdn.xitu.io/2019/3/22/169a2cd4fe961a90?w=960&amp;h=260&amp;f=jpeg&amp;s=58713\" alt></p>\n</div>",
            "title": "[译]使用 JavaScript 对象 Rest 和 Spread 的7个技巧",
            "last_reply_at": "2019-03-22T01:53:03.554Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 106,
            "create_at": "2019-03-22T00:34:13.709Z",
            "author": {
                "loginname": "oliyg",
                "avatar_url": "https://avatars1.githubusercontent.com/u/19631785?v=4&s=120"
            }
        }, {
            "id": "5b7ac9c7c52ad1482eb940bf",
            "author_id": "5b52cbf1fb9e84ec69cc1ca2",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>Egg.js现在用的人多吗？那些公司在用有知道的吗？</p>\n<p>同上，老铁们出来吧。</p>\n</div>",
            "title": "Egg.js现在用的人多吗？那些公司在用有知道的吗？",
            "last_reply_at": "2019-03-22T01:27:56.233Z",
            "good": false,
            "top": false,
            "reply_count": 81,
            "visit_count": 7744,
            "create_at": "2018-08-20T14:01:43.981Z",
            "author": {
                "loginname": "nodeper",
                "avatar_url": "https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"
            }
        }, {
            "id": "5b8de66137b3005a0b0e6b3f",
            "author_id": "5b8de41bbf116a8c0e42579f",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>Egg.js入门视频教程主要讲了Egg的环境搭建   egg的控制器      egg服务  egg中间件   egg路由 egg扩展   egg模板引擎  egg cookie   egg session</p>\n<p><strong>Eggjs 视频教程百度网盘分享接</strong>： <a href=\"https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w\">https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w</a></p>\n<p><strong>或者此连接Egg.js视频教程10讲入门链接</strong>： <a href=\"https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg\">https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg</a>  <strong>密码</strong>：4b6i</p>\n<p><strong>来源</strong>  <a href=\"https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf\">https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf</a></p>\n<p>希望老铁门能喜欢\n<img src=\"//static.cnodejs.org/FoPZNWCMpHqWFAb2QDns-UhIMX-3\" alt=\"egg01.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fu4_-OevpWiKHFqeEGBOW53MCdnE\" alt=\"egg02.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtOEkaeRTUNyuWE2mhvazrxPc6cd\" alt=\"egg03.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtJsuDe3kbcNYWWcJyfxuE08wVs5\" alt=\"egg05.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fp8erhbPkGZrsYFsd-gxn2z4Gssb\" alt=\"222.png\"></p>\n<p><img src=\"//static.cnodejs.org/FhCAuCKVwbQnTCJWtkGKv6ZR8toN\" alt=\"06.png\"></p>\n</div>",
            "title": "Egg.js视频教程-Eggjs入门视频教程网盘免费分享-10讲入门基础希望老铁门能喜欢",
            "last_reply_at": "2019-03-22T01:26:04.744Z",
            "good": false,
            "top": false,
            "reply_count": 88,
            "visit_count": 10751,
            "create_at": "2018-09-04T01:56:49.179Z",
            "author": {
                "loginname": "zlyuanteng",
                "avatar_url": "https://avatars0.githubusercontent.com/u/42952042?v=4&s=120"
            }
        }, {
            "id": "5bb0bf6f37a6965f59051df3",
            "author_id": "5ba61ea38f5b0c1c59ea10b6",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h2>在线体验地址:<a href=\"http://vip.52tech.tech/\">http://vip.52tech.tech/</a></h2>\n<h2>GIthub源码：<a href=\"https://github.com/xiugangzhang/vip.github.io\">https://github.com/xiugangzhang/vip.github.io</a></h2>\n<h2>项目预览</h2>\n<p><img src=\"//static.cnodejs.org/FmjZMm4b3MUqJIuSB5aYS2PEW0pf\" alt=\"preview.jpg\"></p>\n<ul>\n<li>主页面\n<img src=\"//static.cnodejs.org/FhTjrj9HgY37ojGYNdLWupmBfSyv\" alt=\"preview.jpg\"></li>\n<li>登录页面\n<img src=\"//static.cnodejs.org/FrZr5Mck4VQD9ndVXhJGqA9XwHsU\" alt=\"login.jpg\"></li>\n<li>注册页面\n<img src=\"//static.cnodejs.org/FnXwM1CtMBcA7cFv66vlYb-t559E\" alt=\"register.jpg\"></li>\n<li>会员中心\n<img src=\"//static.cnodejs.org/FtCfCUeeIA8Y0WnYkhvzqlweqPbs\" alt=\"user.jpg\"></li>\n<li>电影播放页面\n<img src=\"//static.cnodejs.org/FryrTyzEeEFuOgD1uXrkwF4MzXn-\" alt=\"play.jpg\"></li>\n<li>电影弹幕功能\n<img src=\"//static.cnodejs.org/FhcOXAvbMZuafMrJzU00fMvRXot9\" alt=\"danmu.jpg\"></li>\n</ul>\n<h2>视频网站项目已经完功能如下：</h2>\n<h3>v1.0.3（当前最新版本）</h3>\n<ul>\n<li>\n<ol>\n<li>增加自动抓取功能，网站数据定期实时更新</li>\n</ol>\n<ul>\n<li>电影和电视剧数据抓取</li>\n<li>电影数据信息前端展现</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>电影页面图片的自动抓取、下载和展示</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>代码结构调整</li>\n</ol>\n</li>\n</ul>\n<h3>v1.0.2</h3>\n<ul>\n<li>\n<ol>\n<li>简化程序安装流程，新增可视化安装界面</li>\n</ol>\n<ul>\n<li>用户可直接输入数据库名、数据库地址、数据库用户名、数据库密码信息一键完成程序的安装</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>页面部分结构的调整</li>\n</ol>\n</li>\n</ul>\n<h3>v1.0.1</h3>\n<ul>\n<li>\n<ol>\n<li>用户中心的管理</li>\n</ol>\n<ul>\n<li>对于已经注册的用户，实现用户基本信息的修改</li>\n<li>用户密码的修改</li>\n<li>用户评论记录的查看</li>\n<li>用户收藏电影的查看和播放</li>\n<li>用户登录日志的查看</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>电影搜索功能（特色功能）</li>\n</ol>\n<ul>\n<li>实现了根据视频播放地址和视频名称全网视频的搜索和播放功能</li>\n<li>实现了正在热映，即将上映和TOP250的电影列表的展示</li>\n<li>电影收藏和取消功能</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>弹幕功能（特色功能）</li>\n</ol>\n<ul>\n<li>类似于B站等其他视频网站的弹幕功能，用户在登录之后可以实现在线发言</li>\n</ul>\n</li>\n</ul>\n<h3>v1.0.0</h3>\n<ul>\n<li>\n<ol>\n<li>用户主页的搭建：</li>\n</ol>\n<ul>\n<li>实现了主页轮播图的显示和切换，用户可以从数据库中自由配置和切换轮播图的显示</li>\n<li>实现了主页电影列表的显示：从数据库文件读取电影和电视剧列表信息并在前台显示</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>用户登录和注册页面的搭建：</li>\n</ol>\n<ul>\n<li>实现了用户的登录和注册功能</li>\n<li>用户注册和登录验证码提示功能</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>电影播放页面的搭建</li>\n</ol>\n<ul>\n<li>对于其他页面的任意可以展现电影列表的页面，用户可以直接点击列表，直接进入播放页面</li>\n<li>播放页面电影详细信息的展现</li>\n<li>对于加载速度较慢的视频，用户可以自由切换播放接口进行加速</li>\n<li>用户可以在相应的播放页面查看其他用户已经发表的评论，同时也可以在登录之后自由发表评论</li>\n</ul>\n</li>\n</ul>\n<h3>其他</h3>\n<ul>\n<li>\n<ol>\n<li>页面整体的风格模仿了Discuz等论坛网站的布局</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>网站首页的轮播图效果模仿了优酷、爱奇艺、腾讯视频等主流视频网站的轮播图效果，并且对该部分的效果实现进行了代码封装</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>电影底部的的友情链接，使用了大部分网站的分栏布局，用户可以添加自己的QQ群以及微信公众号方便增加自己网站的人气</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>主要列表的分页功能，对于一些内容显示较多的不能再一页显示完整的页面，使用了ajax无刷新分页对数据进行多条展示，提高了用户的体验</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>目前主流浏览器中也做了相应测试，建议大家使用谷歌或者火狐浏览器，效果可能会更好</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>未使用其他第三方框架，首页和播放页均为纯原生的HTML，CSS， js实现（至于这个xframe-min-1.0.js文件可以参见我的GitHub xframe.js这个开源项目）</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>电影播放页面：此处也是类似于当前主流网站的的播放页面，左侧为播放窗口，右侧部分为电影的详细信息</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>底部导航：使用分栏的方式实现了底部的导航，前面的为友情链接，后面的一个为网站的微信，Q微博等联系方式</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>用户中心：这部分实现了修改密码，评论，登录，日志管理，收藏电影的功能，用户可以自由切换</li>\n</ol>\n</li>\n</ul>\n<h2>程序目录结构说明</h2>\n<pre class=\"prettyprint\"><code>vip.github.io:\n├─controllers               &#x2F;&#x2F; 控制层\n├─data                      &#x2F;&#x2F; 数据抓取层\n├─logs                      &#x2F;&#x2F; 后台日志\n│  ├─errlog                 &#x2F;&#x2F; 错误日志\n│  ├─othlog                 &#x2F;&#x2F; 其他日志\n│  └─reqlog                 &#x2F;&#x2F; 请求日志\n├─models                    &#x2F;&#x2F; 模型层\n├─static                    &#x2F;&#x2F; 静态页\n│  ├─css                    &#x2F;&#x2F; 样式表\n│  ├─images                 &#x2F;&#x2F; 静态图片资源\n│  └─js                     &#x2F;&#x2F; js脚本\n├─utils                     &#x2F;&#x2F; 工具相关\n├─views                     &#x2F;&#x2F; 视图层\n└─www                       &#x2F;&#x2F; 静态资源\n    ├─css                   &#x2F;&#x2F; 样式表\n    ├─html                  &#x2F;&#x2F; html文件\n    ├─images                &#x2F;&#x2F; 静态图片资源\n    ├─js                    &#x2F;&#x2F; js脚本\n    │  └─movielist          &#x2F;&#x2F; 搜索页电影列表\n    │      ├─components     &#x2F;&#x2F; top250&#x2F;即将上映\n    │      └─in_theaters    &#x2F;&#x2F; 正在热映\n    └─uploads               &#x2F;&#x2F; 文件上传目录\n        ├─avatar            &#x2F;&#x2F; 用户图像\n        └─movie             &#x2F;&#x2F; 电影图标\n\n</code></pre><h2>程序安装方法</h2>\n<ul>\n<li>\n<ol>\n<li>确保电脑已经安装了NodeJS环境，运行版本尽量保持最新（V8以上吧），选择本地的一个路径，然后运行命令：</li>\n</ol>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>   git clone https:&#x2F;&#x2F;github.com&#x2F;xiugangzhang&#x2F;vip.github.io.git\n</code></pre><ul>\n<li>\n<ol>\n<li>进入程序的主目录（包含app.js的那个文件夹）运行命令：npm install，系统就会自动安装该程序的依赖包；</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>在以上的步骤都执行完成且正确的情况下，就可以在程序主目录下面（有app.js的那个目录）,运行命令</li>\n</ol>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>   node app.js\n</code></pre><p>之后就会自动在浏览器中打开本程序安装的主界面；</p>\n<ul>\n<li>\n<ol>\n<li>如果是windows环境下，本程序提供了可视化的安装。用户可在程序的安装界面输入数据库名、数据库主机地址、数据库用户名、数据库密码，之后点击按钮立即安装即可，在输入的参数全部正确的情况下，就会后台自动安装程序，安装成功之后会自动跳转到网站首页；\n<img src=\"//static.cnodejs.org/FqNdjsfo5whahU-WvEC8WOpBBXA5\" alt=\"installing.jpg\"></li>\n</ol>\n</li>\n<li>\n<ol>\n<li>如果是Linux环境下，请提前准备好数据库名（database=video）、数据库主机地址（host=localhost）、数据库用户名（user=root）、数据库密码（password=123456 ），按照如下格式保存为config.properties文件，请确保这里的配置信息和你的数据库配置信息完全一致；</li>\n</ol>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>    database=video               \n    host=localhost          \n    user=root               \n    password=123456         \n</code></pre><ul>\n<li>\n<ol>\n<li>在线演示站点：<a href=\"http://vip.52tech.tech\">http://vip.52tech.tech</a></li>\n</ol>\n</li>\n<li>\n<ol>\n<li>对于安装和使用的过程中如果有什么问题和建议，也欢迎交流和提出建议，可以在issue去发起话题讨论，或直接联系邮箱：tech52admin@126.com</li>\n</ol>\n</li>\n</ul>\n</div>",
            "title": "【VIP视频网站项目】基于Nodejs开发的VIP视频网站项目及源码分享【v1.0.3版】",
            "last_reply_at": "2019-03-21T16:45:04.160Z",
            "good": false,
            "top": false,
            "reply_count": 23,
            "visit_count": 14561,
            "create_at": "2018-09-30T12:19:59.585Z",
            "author": {
                "loginname": "xiugangzhang",
                "avatar_url": "https://avatars3.githubusercontent.com/u/29092258?v=4&s=120"
            }
        }, {
            "id": "5c4937c73b948a2b4ab710f0",
            "author_id": "5b1d495729e6e510415b29b0",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>老代码用的是es5的规范，然后有些模块也已经很老了（express用的3.x）。能否在模块不变的情况下，将node版本升级到最新的持久版，然后将老代码的回调改成async/await ？</p>\n</div>",
            "title": "公司项目升级，大佬们有什么建议吗？",
            "last_reply_at": "2019-03-21T14:10:05.064Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 1599,
            "create_at": "2019-01-24T03:57:59.963Z",
            "author": {
                "loginname": "helloHT",
                "avatar_url": "https://avatars3.githubusercontent.com/u/31006740?v=4&s=120"
            }
        }, {
            "id": "596eb7768f05de0819fdb301",
            "author_id": "538ebff9c3ee0b58208376c7",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>如题。知道内情的进来说说？<a href=\"/user/alsotang\">@alsotang</a> and <a href=\"/user/i5ting\">@i5ting</a>？</p>\n</div>",
            "title": "听说明年2月之前要禁止所有个人用户使用VPN，是真的吗？",
            "last_reply_at": "2019-03-21T06:22:54.582Z",
            "good": false,
            "top": false,
            "reply_count": 39,
            "visit_count": 7078,
            "create_at": "2017-07-19T01:35:50.929Z",
            "author": {
                "loginname": "zhanzhenzhen",
                "avatar_url": "https://avatars3.githubusercontent.com/u/731796?v=4&s=120"
            }
        }, {
            "id": "5c8e18657ce0df3732428da8",
            "author_id": "5ac77987e34737560fccaa7b",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><img src=\"https://unsplash.it/1380/825?random\" alt=\"image\"></p>\n<p>&lt;!–more–&gt;</p>\n<h2>前言</h2>\n<p>数据结构和算法的知识博大精深, 这里只是对这几种数据结构做一些简单的介绍。并对leetcode上部分相关的简单和中等题做出解答。还请各位看官见谅</p>\n<h2>二叉树</h2>\n<p>二叉树是一种典型的树状结构, 二叉树每一个节点最多有两个子树的结构。以下是遍历二叉树的几种方式, 总的来说使用递归的方式, 还是非常好理解的。</p>\n<p><img src=\"https://i.loli.net/2019/03/16/5c8d0e77d7aaf.png\" alt=\"image\"></p>\n<h3>深度优先遍历 前序遍历</h3>\n<p>前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树</p>\n<p>节点遍历的顺序: <strong>F, B, A, D, C, E, G, I, H</strong></p>\n<pre class=\"prettyprint language-js\"><code>\nvar preorderTraversal = function (root) {\n  let result = []\n\n  const traversing = (node) =&gt; {\n    &#x2F;&#x2F; 结束递归\n    if (!node) return []\n\n    &#x2F;&#x2F; 首先遍历当前的节点\n    result.push(node.val)\n    &#x2F;&#x2F; 如果有左子树优先遍历左子树\n    if (node.left) {\n      result.concat(traversing(node.left))\n    }\n    &#x2F;&#x2F; 遍历又子树\n    if (node.right) {\n      result.concat(traversing(node.right))\n    }\n  }\n\n  traversing(root)\n\n  return result\n}\n</code></pre><h3>深度优先遍历 中序遍历</h3>\n<p>中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树</p>\n<p>节点遍历的顺序: <strong>A, B, C, D, E, F, G, H, I</strong></p>\n<pre class=\"prettyprint language-js\"><code>\nvar inorderTraversal = function (root) {\n  let result = []\n  const traversing = (node) =&gt; {\n    if (!node) return\n    &#x2F;&#x2F; 优先遍历左子树\n    if (node.left) {\n      traversing(node.left)\n    }\n    &#x2F;&#x2F; 然后获取当前的节点\n    if (node.val) {\n      result.push(node.val)\n    }\n    &#x2F;&#x2F; 然后遍历右子树\n    if (node.right) {\n      traversing(node.right)\n    }\n  }\n  traversing(root)\n  return result\n}\n</code></pre><h3>深度优先遍历 后序遍历</h3>\n<p>先遍历左子树，然后遍历右子树，最后访问树的根节点</p>\n<p>节点遍历的顺序: <strong>A, C, E, D, B, H, I, G, F</strong></p>\n<pre class=\"prettyprint language-js\"><code>\nvar postorderTraversal = function (root) {\n  let result = []\n  const traversing = (node) =&gt; {\n    if (!node) return\n    if (node.left) {\n      traversing(node.left)\n    }\n    if (node.right) {\n      traversing(node.right)\n    }\n    if (node.val) {\n      result.push(node.val)\n    }\n  }\n  traversing(root)\n  return result\n};\n</code></pre><h3>广度优先遍历</h3>\n<p>广度优先搜索是一种广泛运用在树或图这类数据结构中，遍历或搜索的算法。该算法从一个根节点开始，首先访问节点本身。然后依次遍历它的二级邻节点、三级邻节点，以此类推。我们这里依然使用递归遍历, 但是我们在递归中添加level参数用来确定当前节点的层级。</p>\n<p><img src=\"https://i.loli.net/2019/03/17/5c8dc14a0c96d.png\" alt=\"image\"></p>\n<pre class=\"prettyprint language-js\"><code>\nvar levelOrder = function (root) {\n  let result = []\n\n  const traversing = (node, level) =&gt; {\n    if (!node) return\n    if (!result[level]) result[level] = []\n    result[level].push(node.val)\n    if (node.left) {\n      traversing(node.left, level + 1)\n    }\n    if (node.right) {\n      traversing(node.right, level + 1)\n    }\n  }\n\n  traversing(root, 0)\n  return result\n}\n</code></pre><h3>二叉树的最大深度</h3>\n<h4>题目</h4>\n<p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n<h4>思路</h4>\n<p>对当前的二叉树使用后序遍历。如果当前节点没有左子树并且没有右子树, 说明这个节点是当前分支中最深的节点, 我们记录它自身的最大深度为1(<strong>因为它自身没有子节点</strong>)。如果当前节点有左子树和右子树, 我们取左右子树中最大的深度(<strong>因为是后序遍历, 在遍历当前根节点时, 左右树已经被遍历了</strong>)。取最大深度后加一就是当前节点的深度。</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar maxDepth = function(root) {\n  if (!root) return 0\n\n  const traversing = (node) =&gt; {\n    if (!node) return\n\n    if (!node.left &amp;&amp; !node.right) {\n      node.depth = 1\n      return\n    }\n    if (node.left) {\n      traversing(node.left)\n    }\n    if (node.right) {\n      traversing(node.right)  \n    }\n    let max_left_depth = 0\n    let max_right_depth = 0\n\n    if (node.left) {\n      max_left_depth = node.left.depth\n    }\n    if (node.right) {\n      max_right_depth = node.right.depth\n    }\n\n    node.depth = Math.max(max_left_depth, max_right_depth) + 1\n  }\n\n  traversing(root)\n\n  return root.depth\n}\n</code></pre><h3>对称二叉树</h3>\n<p>给定一个二叉树，检查它是否是镜像对称的</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 对称二叉树\n    1\n   &#x2F; \\\n  2   2\n &#x2F; \\ &#x2F; \\\n3  4 4  3\n\n&#x2F;&#x2F; 不是对称二叉树\n    1\n   &#x2F; \\\n  2   2\n   \\   \\\n   3    3\n</code></pre><h4>思路</h4>\n<p>采用BFS遍历, 获取每一级的所有节点结果集, 不存在的子节点使用null代替。判断每一级的节点是否能构成回文字符串即可。</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar isSymmetric = function(root) {\n  &#x2F;&#x2F; BFS遍历\n  let result = []\n  const traversing = (node, level) =&gt; { \n      \n    if (!result[level]) result[level] = []\n    \n    &#x2F;&#x2F; 不存在的节点使用null填充\n    if (!node) {\n      &#x2F;&#x2F; 终止递归\n      return result[level].push(&#x27;null&#x27;)\n    } else {\n      result[level].push(node.val)\n    }\n      \n    if (node.left) {\n      traversing(node.left, level + 1)\n    } else {\n      traversing(null, level + 1)  \n    }\n      \n    if (node.right) {\n      traversing(node.right, level + 1)\n    } else {\n      traversing(null, level + 1) \n    }\n      \n  }\n  \n  traversing(root, 0)\n  \n  &#x2F;&#x2F; 判断每一级的结果能否构成回文字符串\n  for (let i = 0; i &lt; result.length - 1; i++) {\n    if (result[i].join(&#x27;&#x27;) !== result[i].reverse().join(&#x27;&#x27;)) {\n      return false\n    }\n  }\n  return true\n};\n</code></pre><h3>路径总和</h3>\n<h4>题目</h4>\n<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 给定目标sum = 22\n&#x2F;&#x2F; 5-&gt;4-&gt;11-&gt;2和为22, 返回true\n\n              5\n             &#x2F; \\\n            4   8\n           &#x2F;   &#x2F; \\\n          11  13  4\n         &#x2F;  \\      \\\n        7    2      1\n</code></pre><h4>思路</h4>\n<p>我们采用前序遍历, 每次遍历使用目标减去当前节点的值，并将新的目标带入下一次的递归中。如果当遍历到最深处的节点，并且节点的值等于目标的值。说明二叉树拥有路径的和等于目标值。</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar hasPathSum = function(root, sum) {\n  let result = []\n  const traversing = (root, sum) =&gt; { \n      \n    if (!root) return false\n    \n    &#x2F;&#x2F; 说明拥有路径等于目标的和\n    if (!root.left &amp;&amp; !root.right &amp;&amp; root.val === sum) {\n        result.push(root.val)\n    }\n    \n    if (root.left) {\n        traversing(root.left, sum - root.val) \n    }\n    \n    if (root.right) {\n        traversing(root.right, sum - root.val)\n    } \n  }\n   \n  traversing(root, sum)\n\n  return result.length &gt; 0\n};\n</code></pre><h3>从中序与后序遍历序列构造二叉树</h3>\n<h4>题目</h4>\n<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; 中序遍历 inorder = [9,3,15,20,7]\n&#x2F;&#x2F; 后序遍历 postorder = [9,15,7,20,3]\n\n&#x2F;&#x2F; 构建结果\n    3\n   &#x2F; \\\n  9  20\n    &#x2F;  \\\n   15   7\n</code></pre><h4>思路</h4>\n<p>思路与<strong>从前序与中序遍历序列构造二叉树</strong>题类似，这里不在赘述</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar buildTree = function(inorder, postorder) {\n    let binaryTree = {}\n   \n  const iteration = (postorder, inorder, tree) =&gt; {\n       \n      if (!postorder.length) {\n          binaryTree = null\n          return\n      }\n       \n      tree.val = null\n      tree.left = {\n          val: null,\n          left: null,\n          right: null\n      }\n      tree.right = {\n          val: null,\n          left: null,\n          right: null\n      }\n\n     &#x2F;&#x2F; 前序遍历第一个节点为当前树的根节点\n     let rootVal = postorder.splice(postorder.length - 1, 1)[0]\n     &#x2F;&#x2F; 中序遍历根节点的索引\n     let rootIndex = inorder.indexOf(rootVal)\n     &#x2F;&#x2F; 中序遍历的左子树\n     let inorderLeftTree = inorder.slice(0, rootIndex)\n     &#x2F;&#x2F; 中序遍历的右子树\n     let inorderRightTree = inorder.slice(rootIndex + 1)\n     &#x2F;&#x2F; 前序遍历的左子树\n     let postorderLeftTree = postorder.slice(0, inorderLeftTree.length)\n     &#x2F;&#x2F; 前序遍历的右子树\n     let postorderRightTree = postorder.slice(inorderLeftTree.length)\n\n       \n     tree.val = rootVal\n      \n     if (postorderLeftTree.length === 1 || inorderLeftTree.length === 1) {\n         tree.left.val = postorderLeftTree[0]\n     } else if (postorderLeftTree.length &gt; 1 || inorderLeftTree.length &gt; 1) {\n         iteration(postorderLeftTree, inorderLeftTree, tree.left)\n     } else {\n          tree.left = null\n     }\n       \n     if (postorderRightTree.length === 1 || inorderRightTree.length === 1) {\n         tree.right.val = postorderRightTree[0]\n     } else if (postorderRightTree.length &gt; 1 || inorderRightTree.length &gt; 1) {\n         iteration(postorderRightTree, inorderRightTree, tree.right)\n     } else {\n      tree.right = null\n     }\n  }\n   \n  iteration(postorder, inorder, binaryTree)\n   \n  return binaryTree\n}\n</code></pre><h3>从前序与中序遍历序列构造二叉树</h3>\n<h4>思路</h4>\n<p>本题依然采用递归的思路, 前序遍历的第一个节点为二叉树的根节点，以此作为突破口。</p>\n<p>本题的前置条件是树中不存在重复的元素。可以由中序遍历的结果以及根节点值获取根节点的左子树以及右子树。</p>\n<p>我们这时可以获得根节点左子树和右子树的长度。反过来可以获取前序遍历结果中的左右子树。我们这时，把左右子树再当成一颗二叉树，使用递归的形式重复此过程。既可以推导出整颗二叉树。</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar buildTree = function(preorder, inorder) {\n     \n  let binaryTree = {}\n   \n  const iteration = (preorder, inorder, tree) =&gt; {\n       \n      if (!preorder.length) {\n          binaryTree = null\n          return\n      }\n       \n      tree.val = null\n      tree.left = {\n          val: null,\n          left: null,\n          right: null\n      }\n      tree.right = {\n          val: null,\n          left: null,\n          right: null\n      }\n\n     &#x2F;&#x2F; 前序遍历第一个节点为当前树的根节点\n     let rootVal = preorder.splice(0, 1)[0]\n     &#x2F;&#x2F; 中序遍历根节点的索引\n     let rootIndex = inorder.indexOf(rootVal)\n     &#x2F;&#x2F; 中序遍历的左子树\n     let inorderLeftTree = inorder.slice(0, rootIndex)\n     &#x2F;&#x2F; 中序遍历的右子树\n     let inorderRightTree = inorder.slice(rootIndex + 1)\n     &#x2F;&#x2F; 前序遍历的左子树\n     let preorderLeftTree = preorder.slice(0, inorderLeftTree.length)\n     &#x2F;&#x2F; 前序遍历的右子树\n     let preorderRightTree = preorder.slice(inorderLeftTree.length)\n\n       \n     tree.val = rootVal\n      \n     if (preorderLeftTree.length === 1 || inorderLeftTree.length === 1) {\n         tree.left.val = preorderLeftTree[0]\n     } else if (preorderLeftTree.length &gt; 1 || inorderLeftTree.length &gt; 1) {\n         iteration(preorderLeftTree, inorderLeftTree, tree.left)\n     } else {\n          tree.left = null\n     }\n       \n     if (preorderRightTree.length === 1 || inorderRightTree.length === 1) {\n         tree.right.val = preorderRightTree[0]\n     } else if (preorderRightTree.length &gt; 1 || inorderRightTree.length &gt; 1) {\n         iteration(preorderRightTree, inorderRightTree, tree.right)\n     } else {\n      tree.right = null\n     }\n  }\n   \n  iteration(preorder, inorder, binaryTree)\n   \n  return binaryTree\n}\n</code></pre><h2>二叉搜索树</h2>\n<p>二叉搜索树是二叉树的一种特殊形式。 二叉搜索树具有以下性质：每个节点中的值必须大于（或等于）其左侧子树中的任何值，但小于（或等于）其右侧子树中的任何值。</p>\n<p><strong>对于二叉搜索树，我们可以通过中序遍历得到一个递增的有序序列</strong></p>\n<h3>验证二叉搜索树</h3>\n<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>\n<h4>思路</h4>\n<p>可以通过中序DFS遍历二叉搜索树, 判断遍历的结果是否为递增的数组判断是否为搜索二叉树</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar isValidBST = function(root) {\n    if (!root) return true\n    \n    &#x2F;&#x2F; 中序DFS\n    let result = []    \n\n    const iteration = (root) =&gt; {\n       if (root.left) {\n           iteration(root.left)\n       }\n       result.push(root.val)\n       if (root.right) {\n           iteration(root.right)\n       }\n    }\n    iteration(root)\n    let resultString = result.join(&#x27;,&#x27;)\n    let result2String = [...new Set(result.sort((a, b) =&gt; a - b))].join(&#x27;,&#x27;)\n    return resultString === result2String\n};\n</code></pre><h3>在二叉搜索树中实现搜索操作</h3>\n<p>如果目标值等于节点的值，则返回节点, 如果目标值小于节点的值，则继续在左子树中搜索, 如果目标值大于节点的值，则继续在右子树中搜索。</p>\n<p><img src=\"https://i.loli.net/2019/03/17/5c8deb4c07569.png\" alt=\"image\"></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 递归就完事了\nvar searchBST = function(root, val) {\n    if (!root) return null\n    \n    let result = null\n    \n    const seatch = (node) =&gt; {\n        if (node.val === val) {\n            return result = node\n        } else if (val &gt; node.val &amp;&amp; node.right) {\n            seatch(node.right)\n        } else if (val &lt; node.val &amp;&amp; node.left) {\n            seatch(node.left)\n        }\n    }\n    \n    seatch(root)\n        \n    return result\n};\n</code></pre><h3>在二叉搜索树中实现插入操作</h3>\n<p>在二叉搜索树中的插入操作和搜索操作类似。根据节点值与目标节点值的关系，搜索左子树或右子树。当节点没有左右子树时。判断目标值和当前节点的关系，执行插入的操作。</p>\n<pre class=\"prettyprint language-js\"><code>\nvar insertIntoBST = function(root, val) {\n    const insert = (root) =&gt; {\n        if (val &gt; root.val) {\n            if (root.right) {\n               insert(root.right) \n            } else {\n               root.right = new TreeNode(val)\n            }\n        } else if (val &lt; root.val) {\n            if (root.left) {\n               insert(root.left)  \n            } else {\n               root.left = new TreeNode(val)\n            }\n        }\n    }\n    \n    insert(root)\n    \n    return root\n};\n</code></pre><h3>在二叉搜索树中实现删除操作</h3>\n<p>删除二叉树的节点的操作复杂度远远大于搜索和插入的操作。删除搜索二叉树节点时, 需要考虑多种状态</p>\n<p><img src=\"https://i.loli.net/2019/03/17/5c8dee6d7813b.png\" alt=\"image\"></p>\n<p>删除的节点没有子节点的时候, 直接移除改节点(从它的父节点上移除)</p>\n<p><img src=\"https://i.loli.net/2019/03/17/5c8deec6c6209.png\" alt=\"image\"></p>\n<p>删除的节点只有一个子节点的时候, 需要将需要删除的节点的父节点, 链接上删除节点的子节点。即可完成删除</p>\n<p><img src=\"https://i.loli.net/2019/03/17/5c8def13bd388.png\" alt=\"image\"></p>\n<p>删除的节点有两个子节点的时候, 需要将删除节点右子树中的最小值, 赋予删除的节点。然后删除右子树中的最小值即可。</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n *&#x2F;\n&#x2F;**\n * @param {TreeNode} root\n * @param {number} key\n * @return {TreeNode}\n *&#x2F;\nvar deleteNode = function(root, key) {\n    \n    \n    &#x2F;&#x2F; 根节点为空的情况\n    if (!root) {\n        return null\n    }\n    \n    if (!root.left &amp;&amp; !root.right &amp;&amp; root.val === key) {\n        root = null\n        return root\n    }\n    \n    if (!root.left &amp;&amp; root.right &amp;&amp; root.val === key) {\n        root = root.right\n        return root\n    }\n    \n    if (root.left &amp;&amp; !root.right &amp;&amp; root.val === key) {\n       root = root.left\n        return root\n    }\n    \n    &#x2F;&#x2F; 根节点替换的情况\n    \n    &#x2F;&#x2F; 寻找当前树的最小节点\n    const findMin = (root) =&gt; {\n        let min = root\n        while (min.left) {\n            min = min.left\n        }\n        return min\n    }\n    \n    let parentNode = null\n    \n    &#x2F;&#x2F; 找到最近的父级\n    const searchParent = (node, searchValue) =&gt; {\n        console.log(&#x27;???&#x27;)\n        let current = node\n        let breaker = false\n        \n        while (!breaker) {\n            console.log(&#x27;查找父亲&#x27;)\n            if (\n                (current.left &amp;&amp; searchValue === current.left.val) ||\n                (current.right &amp;&amp; searchValue === current.right.val)\n            ) {\n              breaker = true\n            } else if (searchValue &lt; current.val) {\n              current = current.left\n            } else if (searchValue &gt; current.val) {\n              current = current.right\n            } else {\n              current = null\n            }\n\n            if (!current) break\n        }\n        \n        parentNode = current\n    }\n    \n    const remove = (node, deleteValue) =&gt; {\n        if (node.val === deleteValue) {\n            console.log(&#x27;1&#x27;)\n            &#x2F;&#x2F; node为要删除的节点\n            if (!node.left &amp;&amp; !node.right) {\n                console.log(&#x27;3&#x27;)\n                &#x2F;&#x2F; 如果没有任何子节点\n                searchParent(root, node.val)\n                if (parentNode.left &amp;&amp; parentNode.left.val === deleteValue) {\n                    parentNode.left = null\n                } else {\n                    parentNode.right = null\n                }\n            } else if (!node.left &amp;&amp; node.right) {\n                console.log(&#x27;4&#x27;)\n                &#x2F;&#x2F; 如果只有一个子节点\n                searchParent(root, node.val)\n                if (parentNode.left &amp;&amp; parentNode.left.val === deleteValue) {\n                    parentNode.left = node.right\n                } else {\n                    parentNode.right = node.right\n                }\n            } else if (node.left &amp;&amp; !node.right) {\n                console.log(&#x27;5&#x27;)\n                &#x2F;&#x2F; 如果只有一个子节点\n                searchParent(root, node.val)\n                if (parentNode.left &amp;&amp; parentNode.left.val === deleteValue) {\n                    parentNode.left = node.left\n                } else {\n                    parentNode.right = node.left\n                }\n            } else {\n                console.log(&#x27;6&#x27;)\n                &#x2F;&#x2F; 如果有两个子节点\n                &#x2F;&#x2F; 找到右子树中最小的节点\n                let minNode = findMin(node.right)\n                console.log(&#x27;7&#x27;)\n                let minNodeValue = minNode.val\n                console.log(&#x27;8&#x27;)\n                remove(root, minNodeValue)\n                console.log(&#x27;9&#x27;)\n                node.val = minNodeValue\n                console.log(&#x27;10&#x27;)\n            }\n        } else if (deleteValue &gt; node.val &amp;&amp; node.right) {\n            console.log(&#x27;2&#x27;)\n            remove(node.right, deleteValue)\n        } else if (deleteValue &lt; node.val &amp;&amp; node.left) {\n            console.log(&#x27;3&#x27;)\n            remove(node.left, deleteValue)\n        }\n    }\n    \n    remove(root, key)\n    \n    return root\n};\n</code></pre><h3>二叉搜索树的最近公共祖先</h3>\n<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>\n<h4>思路</h4>\n<p>从根节点开始遍历操作, 如果根节点的值大于目标节点1, 小于目标节点2。说明根节点就是最近的公共祖先。</p>\n<p>如果根节点大于目标节点1, 目标节点2，则使用根节点的左子节点重复前一步的操作。</p>\n<p>如果根节点小于目标节点1, 目标节点2，则使用根节点的右子节点重复前一步的操作。</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n *&#x2F;\n&#x2F;**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n *&#x2F;\nvar lowestCommonAncestor = function(root, p, q) {\n    if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) {\n        return lowestCommonAncestor(root.left, p, q)\n    }\n    if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) {\n        return lowestCommonAncestor(root.right, p, q)\n    }\n    return root\n};\n</code></pre><h2>前缀树</h2>\n<p><img src=\"https://i.loli.net/2019/03/17/5c8df594a7d02.png\" alt=\"image\"></p>\n<p>前缀树是N叉树的一种特殊形式。前缀树的每一个节点通常表示一个字符或者字符串。每一个节点拥有多个不同的子节点。值得注意的是，根节点表示空字符串。</p>\n<p><strong>前缀树的一个重要的特性是，节点所有的后代都与该节点相关的字符串有着共同的前缀。这就是前缀树名称的由来。</strong></p>\n<h3>如何表示一个Trie树?</h3>\n<p>方法1, 使用长度为26的数组存储子节点</p>\n<p>方法2, 使用hashMap存储子节点</p>\n<h3>实现 Trie (前缀树)</h3>\n<pre class=\"prettyprint language-js\"><code>\nvar TrieNode = function (val = null) {\n    &#x2F;&#x2F; 当前的值\n    this.val = val\n    &#x2F;&#x2F; 当前节点的子节点\n    this.children = {}\n    &#x2F;&#x2F; 表示当前节点是否为一个单词\n    this.isWord = false\n}\n\n&#x2F;&#x2F; 添加到节点\nTrieNode.prototype.add = function (val) {\n    let child = new TrieNode(val)\n    this.children[val] = child\n    return this.children[val]\n}\n\n&#x2F;&#x2F; 判断是否包含子节点\nTrieNode.prototype.has = function (val) {\n    return this.children[val] ? true : false\n}\n\n&#x2F;**\n * Initialize your data structure here.\n *&#x2F;\nvar Trie = function() {\n    &#x2F;&#x2F; 初始化根节点\n    this.root = new TrieNode(&#x27;&#x27;)\n};\n\n&#x2F;**\n * Inserts a word into the trie. \n * @param {string} word\n * @return {void}\n *&#x2F;\nTrie.prototype.insert = function(word) {\n    let current = this.root\n    let words = word.split(&#x27;&#x27;)\n    let i = 0\n    &#x2F;&#x2F; 替换最后一个节点\n    while (i &lt; words.length) {\n        if (!current.has(words[i])) {\n           &#x2F;&#x2F; 如果不存在该子节点\n           current = current.add(words[i])\n        } else {\n           &#x2F;&#x2F; 如果存在该子节点\n           current = current.children[words[i]]\n        }\n        i += 1\n    }\n    current.isWord = true\n};\n\n&#x2F;**\n * Returns if the word is in the trie. \n * 判断是否存在单词\n * @param {string} word\n * @return {boolean}\n *&#x2F;\nTrie.prototype.search = function(word) {\n    let current = this.root\n    let words = word.split(&#x27;&#x27;)\n    let i = 0\n    let result = null\n    while (i &lt; words.length) {\n        if (current.has(words[i])) {\n            current = current.children[words[i]]\n            i += 1 \n        } else {\n            return false\n        }\n    }\n    return current.isWord\n\n};\n\n&#x2F;**\n * Returns if there is any word in the trie that starts with the given prefix. \n * 判断是否包含单词\n * @param {string} prefix\n * @return {boolean}\n *&#x2F;\nTrie.prototype.startsWith = function(prefix) {\n    let current = this.root\n    let prefixs = prefix.split(&#x27;&#x27;)\n    let i = 0\n    while (i &lt; prefixs.length) {\n        if (current.has(prefixs[i])) {\n            current = current.children[prefixs[i]]\n            i += 1 \n        } else {\n            return false\n        }\n    }\n    return true\n};\n\n&#x2F;** \n * Your Trie object will be instantiated and called as such:\n * var obj = Object.create(Trie).createNew()\n * obj.insert(word)\n * var param_2 = obj.search(word)\n * var param_3 = obj.startsWith(prefix)\n *&#x2F;\n</code></pre><h3>单词替换</h3>\n<p>在英语中，我们有一个叫做 词根(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。</p>\n<p>现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。</p>\n<p>输入: dict(词典) = [“cat”, “bat”, “rat”]</p>\n<p>sentence(句子) = “the cattle was rattled by the battery”</p>\n<p>输出: “the cat was rat by the bat”</p>\n<h4>思路</h4>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar replaceWords = function(dict, sentence) {\n    let sentences = sentence.split(&#x27; &#x27;)\n    let result = []\n    \n    for (let i = 0; i &lt; sentences.length; i++) {\n        let trie = new Trie()\n        &#x2F;&#x2F; 句子中的每一个词形成一个前缀树\n        trie.insert(sentences[i])\n        let min = sentences[i]\n        for (let j = 0; j &lt; dict.length; j++) {\n            &#x2F;&#x2F; 判断是否包含词根\n            if (trie.startsWith(dict[j])) {\n                &#x2F;&#x2F; 取最短的词根\n                min = min.length &lt; dict[j].length ? min : dict[j]\n            }\n        }\n        result.push(min)\n    }\n    \n    return result.join(&#x27; &#x27;)\n};\n</code></pre><h2>N叉树</h2>\n<p><img src=\"https://i.loli.net/2019/03/17/5c8dfa8e7d92a.png\" alt=\"image\"></p>\n<h3>N叉树的前序遍历</h3>\n<p>先访问根节点，然后以此遍历根节点的所有子节点。如果子节点存在子节点。同根节点一样，先遍历自身然后遍历它的子节点。</p>\n<pre class=\"prettyprint language-js\"><code>\nvar preorder = function(root) {\n    \n    let result = []\n    \n    const iteration = (root) =&gt; {\n        if (!root) return\n        \n        result.push(root.val)\n        \n        if (root.children) {\n           for (let i = 0; i &lt; root.children.length; i++) {\n                iteration(root.children[i]) \n           } \n        }\n    }\n    \n    iteration(root)\n    \n    return result\n}\n</code></pre><h3>N叉树的后序遍历</h3>\n<p>优先遍历根节点的所有子节点，如果子节点存在子节点，则优先遍历其它的子节点</p>\n<pre class=\"prettyprint language-js\"><code>\nvar postorder = function(root) {\n    let result = []\n    \n    const iteration = (root) =&gt; {\n        if (!root) return\n        \n        if (root.children) {\n            for (let i = 0; i &lt; root.children.length; i++) {\n                iteration(root.children[i])\n            }\n        }\n        \n        result.push(root.val)\n    }\n    \n    iteration(root)\n    \n    return result\n};\n</code></pre><h3>N叉树的层序遍历</h3>\n<pre class=\"prettyprint language-js\"><code>\nvar levelOrder = function (root) {\n    let reuslt = []\n\n    const iteration = (root, level) =&gt; {\n        if (!root) return\n\n        if (!reuslt[level]) {\n            reuslt[level] = []\n        }\n\n        reuslt[level].push(root.val)\n\n        for (let i = 0; i &lt; root.children.length; i++) {\n            iteration(root.children[i], level + 1)\n        }\n    }\n\n    iteration(root, 0)\n\n    return reuslt\n};\n</code></pre><h3>N叉树最大深度</h3>\n<p>给定一个 N 叉树，找到其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>\n<h4>思路</h4>\n<p>思路很简单, BFS整个N叉树, 返回结果的长度即可</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar maxDepth = function(root) {\n    let reuslt = []\n\n    const iteration = (root, level) =&gt; {\n        if (!root) return\n\n        if (!reuslt[level]) {\n            reuslt[level] = []\n        }\n\n        reuslt[level].push(root.val)\n\n        for (let i = 0; i &lt; root.children.length; i++) {\n            iteration(root.children[i], level + 1)\n        }\n\n    }\n\n    iteration(root, 0)\n\n    return reuslt.length\n};\n</code></pre></div>",
            "title": "【写的很浅显】 二叉树, 前缀树, N叉树",
            "last_reply_at": "2019-03-21T06:08:46.749Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 425,
            "create_at": "2019-03-17T09:50:29.393Z",
            "author": {
                "loginname": "BengBu-YueZhang",
                "avatar_url": "https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"
            }
        }, {
            "id": "5c92310e8a587f26b426d13f",
            "author_id": "59bb6e2d3c896622428ec766",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>如题，我们服务的架构大概是:microservice-&gt;nginx-&gt;microservice。老大说，nginx上记录到长连接的比例很低，大量的1。但是我们的node服务是有这个的：\nhttp.globalAgent.keepAlive = true\nhttp.globalAgent.keepAliveMsecs = 60 * 1000</p>\n</div>",
            "title": "怎么才能监控node服务的长连接和短连接的比列？",
            "last_reply_at": "2019-03-21T04:33:18.305Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 261,
            "create_at": "2019-03-20T12:24:46.178Z",
            "author": {
                "loginname": "gyj1278",
                "avatar_url": "https://avatars0.githubusercontent.com/u/12684904?v=4&s=120"
            }
        }, {
            "id": "51508570604b3d512113f1b3",
            "author_id": "4fa8ab21b92b054850016ccf",
            "content": "<div class=\"markdown-text\"><p>这个问题困扰我很久了，一致没有想明白。\n这个表有100万的document，我需要遍历他，每次拿出来10条文档，对其进行1个比较耗时的处理，会利用callback返回，进行下10条文档的处理。\n直接使用如下代码，把所有100万数据都放入内存，然后利用async处理，我知道比较蠢，测试了一下，内存猛涨</p>\n<blockquote>\n<p>Blockquote\nMyModel.find({}, function (err, docs) { dosomething(docs,callback)});\nBlockquote</p>\n</blockquote>\n<p>这里请教一下大侠们，可否指点一下方法，使得可以遍历完成100万数据的处理，并且不会引起内存骤增，谢谢了！</p>\n</div>",
            "title": "如何使用mongoose对一个100万+的mongodb的表进行遍历操作",
            "last_reply_at": "2019-03-21T03:12:58.026Z",
            "good": false,
            "top": false,
            "reply_count": 16,
            "visit_count": 32821,
            "create_at": "2013-03-25T17:12:16.919Z",
            "author": {
                "loginname": "askie",
                "avatar_url": "//gravatar.com/avatar/f95eba0fbfdbaa152f4bf59fdc395ae8?size=48"
            }
        }, {
            "id": "5c91da248a587f26b426cd1b",
            "author_id": "55a8ba4c0b9ddb895675df3a",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>把所有东西都放在ctx上面，这样真的合理吗？</p>\n</div>",
            "title": "Egg这样的设计真的合理吗，把所有东西都放在ctx上面",
            "last_reply_at": "2019-03-21T02:49:56.295Z",
            "good": false,
            "top": false,
            "reply_count": 12,
            "visit_count": 668,
            "create_at": "2019-03-20T06:13:56.281Z",
            "author": {
                "loginname": "luluzero",
                "avatar_url": "https://avatars1.githubusercontent.com/u/10164939?v=4&s=120"
            }
        }, {
            "id": "53b93bab1b009b31532ef934",
            "author_id": "50f7a0a9df9e9fcc5889a1b0",
            "content": "<div class=\"markdown-text\"><p>要安全的, 要用gmail.\n封这么厉害…</p>\n</div>",
            "title": "有靠谱的VPN推荐吗?",
            "last_reply_at": "2019-03-21T01:57:41.783Z",
            "good": false,
            "top": false,
            "reply_count": 39,
            "visit_count": 67756,
            "create_at": "2014-07-06T12:06:03.451Z",
            "author": {
                "loginname": "ronincn",
                "avatar_url": "//gravatar.com/avatar/0582e15ee13a3fef9d78dac6f0c71575?size=48"
            }
        }, {
            "id": "5c8f8f6dacb681372d4199d5",
            "author_id": "5b2a60225cd02be6409015ed",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>我在git上删除了一个文件和所有的历史记录，为什么还可以通过这样的方式打开这个文件？求解怎么才能永久删掉。谷歌的方法都没起作用。</p>\n<p>打开方法： <a href=\"http://github.com/xxxx/blob/fab908664c451b996a4a40/xxx.js\">github.com/xxxx/blob/fab908664c451b996a4a40/xxx.js</a>  （类似这样的地址）</p>\n</div>",
            "title": "求解github的一个问题",
            "last_reply_at": "2019-03-21T00:31:15.892Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 497,
            "create_at": "2019-03-18T12:30:37.310Z",
            "author": {
                "loginname": "vitozyf",
                "avatar_url": "https://avatars0.githubusercontent.com/u/26626159?v=4&s=120"
            }
        }, {
            "id": "5c91ae4b8a587f26b426cb63",
            "author_id": "5c91ace496558e26e1b677bd",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>我对于nodejs的多请求处理有些疑惑，希望有人能帮我解答一下。</p>\n<p>1、nodejs 中的cluster是如何均衡负载请求的？\n例如我有1000个请求同时发送到服务器，但是我的服务器只有16核，按照cluster的写法此时我应该有16个worker进程来监听相关事件，那么我这1000个请求是如何分配到16个子进程上的呢？</p>\n<p>2、假如我现在有16个子进程，但是现在请求较少，例如只有10个请求会让我处理，那么剩余6个子进程空闲是否属于资源闲置？我能否利用这六个空闲的进程来处理工作进程中的任务?</p>\n<p>这是我的一些疑惑和设想，希望大家能够指导一下</p>\n</div>",
            "title": "关于Nodejs中cluster的问题",
            "last_reply_at": "2019-03-20T10:14:01.338Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 345,
            "create_at": "2019-03-20T03:06:51.775Z",
            "author": {
                "loginname": "HyperClockUp",
                "avatar_url": "https://avatars2.githubusercontent.com/u/36909196?v=4&s=120"
            }
        }, {
            "id": "5c8f7aac7ce0df37324297af",
            "author_id": "597409048f0313ff0d08d701",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>感觉可以浏览器直连,断点调试node项目,非常方便啊</p>\n</div>",
            "title": "有人在测试环境开启--inspect模式的吗",
            "last_reply_at": "2019-03-20T09:54:01.980Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 272,
            "create_at": "2019-03-18T11:02:04.915Z",
            "author": {
                "loginname": "Liaozhenting",
                "avatar_url": "https://avatars0.githubusercontent.com/u/20339251?v=4&s=120"
            }
        }, {
            "id": "5c9122ff8a587f26b426c8df",
            "author_id": "5c9120fa8a587f26b426c8d9",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>sub-app在init中lazyrouter时会通过this._router.use(middleware.init(this))设置sub-app的req和res的原型指向sub-app的request和response。代码：    setPrototypeOf(req, app.request) setPrototypeOf(res, app.response)，\n但用app.use（sub-app）进行挂载时会执行<br>\nrouter.use(path, function mounted_app(req, res, next) {\nvar orig = req.app;\nfn.handle(req, res, function (err) {\nsetPrototypeOf(req, orig.request)\nsetPrototypeOf(res, orig.response)\nnext(err);\n});\n});\n\t这里是不是把sub-app的req和res重新挂在到app的request和response上面了呢？如果是的目的是什么？</p>\n</div>",
            "title": "关于express sub-app挂载源码部分问题",
            "last_reply_at": "2019-03-20T04:25:58.285Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 222,
            "create_at": "2019-03-19T17:12:31.973Z",
            "author": {
                "loginname": "2015308200114dujiawei",
                "avatar_url": "https://avatars3.githubusercontent.com/u/31696279?v=4&s=120"
            }
        }, {
            "id": "5a311f729807389a1809f37a",
            "author_id": "57b99bc2dcaeb5d932db220a",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h1>Web性能</h1>\n<p>从底层计算机网络协议到应用层各个方面去理解Web性能。目前项目处于刚开始阶段，欢迎对性能优化感兴趣的同学共同参与总结！</p>\n<p>Github: <a href=\"https://github.com/laoqiren/web-performance\">https://github.com/laoqiren/web-performance</a></p>\n<h2>目录</h2>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/README.md\">网页渲染原理</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.md\">渲染过程</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.md\">资源加载顺序</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.md\">浏览器优化策略</a></li>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/repaint%E4%B8%8Ereflow.md\">repaint与reflow</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/tree/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F\">带宽与延迟</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%BC%80%E5%A7%8B.md\">从输入URL开始</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F.md\">带宽与延迟</a></li>\n<li>TCP协议细节</li>\n<li>HTTP 1.x性能</li>\n<li>针对性优化</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/README.md\">缓存机制</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.md\">首部字段</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA.md\">浏览器行为</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E4%BC%98%E5%8C%96.md\">优化</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/tree/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90\">静态资源</a>\n<ul>\n<li>减少请求</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9.md\">资源压缩</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96.md\">图片资源优化</a></li>\n<li>Webpack</li>\n<li>CDN</li>\n</ul>\n</li>\n<li>Virtual DOM\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E8%99%9A%E6%8B%9FDOM/React%E5%9F%BA%E7%A1%80.md\">React基础</a></li>\n<li>实现</li>\n<li>diff算法</li>\n<li>性能考虑</li>\n</ul>\n</li>\n<li>SPA与SSR\n<ul>\n<li>SPA问题</li>\n<li>服务端渲染</li>\n<li>同构应用</li>\n<li>性能问题</li>\n</ul>\n</li>\n<li>HTTP2\n<ul>\n<li>新特性概览</li>\n<li>性能提升</li>\n<li>工程实践</li>\n</ul>\n</li>\n<li>HTTPS性能影响\n<ul>\n<li>TLS原理</li>\n<li>性能影响</li>\n</ul>\n</li>\n<li>高性能JavaScript\n<ul>\n<li>V8与JIT</li>\n<li>内存泄露</li>\n<li>GC机制</li>\n<li>算法与流程</li>\n<li>Web worker</li>\n</ul>\n</li>\n<li>WebAssembly</li>\n<li>PWA与离线应用</li>\n<li>即时运用与P2P</li>\n<li>Node.js性能优化</li>\n<li>集群与负载均衡</li>\n<li>数据库相关</li>\n<li>性能测试\n<ul>\n<li>Chrome开发者工具</li>\n<li>benchmark</li>\n<li>压力测试</li>\n</ul>\n</li>\n</ul>\n<h2>引用说明</h2>\n<p>此项目会引用许多其他文章书籍的图片或部分内容，我会尽量都加以注明，如果有部分遗漏以致于侵犯到您的版权，烦请联系我修改！此项目旨在整理零碎的知识和实践方案，方便交流学习，请勿用于商业用途。</p>\n<h2>参与贡献</h2>\n<ul>\n<li>提想法和建议</li>\n<li>纠错完善</li>\n<li>增加新章节或内容</li>\n</ul>\n</div>",
            "title": "性能优化知识与实践整理",
            "last_reply_at": "2019-03-20T03:54:54.608Z",
            "good": false,
            "top": false,
            "reply_count": 16,
            "visit_count": 6623,
            "create_at": "2017-12-13T12:39:14.755Z",
            "author": {
                "loginname": "laoqiren",
                "avatar_url": "https://avatars2.githubusercontent.com/u/16136702?v=4&s=120"
            }
        }, {
            "id": "5c90507096558e26e1b66b57",
            "author_id": "580f6fcab37ee8fb339787ea",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>使用nuxt跟eggjs做的服务端渲染，目前遇到问题了，在about页面刷新，eggjs的中间件拿不到用户的session了，哪位大佬帮看看，不知道是nuxt这边的问题还是eggjs这边的问题</p>\n<p><a href=\"https://github.com/lzq920/nuxt-eggjs-ssr-template.git\">实例地址</a></p>\n<p>中间件定义</p>\n<pre class=\"prettyprint language-javascript\"><code>const { Nuxt, Builder } = require(&quot;nuxt&quot;);\nlet config = require(&quot;..&#x2F;..&#x2F;nuxt.config&quot;);\nmodule.exports = (options, app) =&gt; {\n  const nuxtRender = new Nuxt(config);\n  let isDev = process.env.NODE_ENV !== &quot;production&quot;;\n  if (isDev) {\n    new Builder(nuxtRender).build();\n  }\n  return async function(ctx, next) {\n    let flag = false;\n    let routerArr = [];\n    if (!flag) {\n      routerArr = app.router.stack.map(el =&gt; el.path);\n      flag = true;\n    }\n    if (routerArr.some(el =&gt; el === ctx.path)) {\n      return await next();\n    }\n    ctx.status = 200;\n    ctx.req.session = ctx.session;\n    const { res, req } = ctx;\n    return new Promise((resolve, reject) =&gt; {\n      ctx.res.on(&quot;close&quot;, resolve);\n      ctx.res.on(&quot;finish&quot;, resolve);\n      nuxtRender.render(req, res, promise =&gt; {\n        promise.then(resolve).catch(reject);\n      });\n    });\n  };\n};\n\n</code></pre><p>about页面请求</p>\n<pre class=\"prettyprint language-javascript\"><code>export default {\n  asyncData({ params }) {\n    return axios.get(&quot;http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;api&#x2F;info&quot;).then(res =&gt; {\n      return { info: res.data };\n    });\n  }\n};\n</code></pre><p>nuxtServerInit定义</p>\n<pre class=\"prettyprint language-javascript\"><code>export const state = () =&gt; ({\n  user: null\n});\n\nexport const mutations = {\n  setUser(state, data) {\n    state.user = data;\n  }\n};\nexport const actions = {\n  nuxtServerInit({ commit }, { req }) {\n    if (req.session.user) {\n      console.log(&quot;client&quot;, req.session.user);\n      commit(&quot;setUser&quot;, req.session.user);\n    }\n  }\n};\n</code></pre></div>",
            "title": "使用nuxt跟eggjs做的服务端渲染，目前遇到问题了，在about页面刷新，eggjs的中间件拿不到用户的session了，哪位大佬帮看看",
            "last_reply_at": "2019-03-20T02:43:11.603Z",
            "good": false,
            "top": false,
            "reply_count": 13,
            "visit_count": 445,
            "create_at": "2019-03-19T02:14:08.258Z",
            "author": {
                "loginname": "lzq920",
                "avatar_url": "https://avatars0.githubusercontent.com/u/37999725?v=4&s=120"
            }
        }, {
            "id": "5c908c8d96558e26e1b66e06",
            "author_id": "5934bb555b07c1b24afa067e",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fi1GE3MmJAEzcRS6QE7fvUUwvKjC\" alt=\"image.png\">\n发发现nodejs的进程的内存逐渐升高，并产生的大量system/JSArrayBufferData，Distance非常大，如图所示，请问这些对象如何分析呢？</p>\n</div>",
            "title": "内存泄漏排查",
            "last_reply_at": "2019-03-20T02:28:02.198Z",
            "good": false,
            "top": false,
            "reply_count": 5,
            "visit_count": 454,
            "create_at": "2019-03-19T06:30:37.885Z",
            "author": {
                "loginname": "zhengboah",
                "avatar_url": "https://avatars3.githubusercontent.com/u/17705410?v=4&s=120"
            }
        }, {
            "id": "5c91a0bc96558e26e1b67722",
            "author_id": "54bc7fde0049cbcc5994c51f",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>多多客（doodooke）是一款支持微信，百度，支付宝小程序的第三方SaaS平台。</p>\n<p><strong>本次重要更新：</strong></p>\n<ol>\n<li>开源diy可视化拖拉拽</li>\n<li>开源taro三端合一小程序</li>\n</ol>\n<p><strong>3.0新特性</strong></p>\n<ol>\n<li>支持migrations，可以快速的创建和修改表</li>\n<li>支持rewrite，可以将请求转发到修改过的接口</li>\n<li>支持view逻辑钩子，可以扩展vue逻辑</li>\n<li>支持view视图钩子，可以扩展vue视图</li>\n<li>支持cluster，可以启动多个项目</li>\n<li>支持本地调试，可以将生产环境的请求转发或复制到本地</li>\n<li>支持bin命令，可以快速的处理migration等</li>\n</ol>\n<p>详情查看<a href=\"https://gitee.com/doodooke/doodoo/releases/3.0.0-alpha.3\">发布日志</a></p>\n<p><strong>仓库</strong></p>\n<ul>\n<li>gitee <a href=\"https://gitee.com/doodooke/doodoo\">https://gitee.com/doodooke/doodoo</a></li>\n<li>github <a href=\"https://github.com/doodooke/doodooke\">https://github.com/doodooke/doodooke</a></li>\n</ul>\n</div>",
            "title": "多多客（doodooke）小程序SaaS平台发布 3.0.0-alpha.3，支持微信，百度，支付宝",
            "last_reply_at": "2019-03-20T02:09:00.553Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 328,
            "create_at": "2019-03-20T02:09:00.553Z",
            "author": {
                "loginname": "einsqing",
                "avatar_url": "https://avatars3.githubusercontent.com/u/7685948?v=4&s=120"
            }
        }, {
            "id": "5c9051248a587f26b426bf4b",
            "author_id": "560b3a2848055cd15e2c8957",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>NutzWk 5.2.0 版本已发布，演示地址： <a href=\"https://nutzwk.wizzer.cn\">https://nutzwk.wizzer.cn</a></p>\n<p>源码Github：<a href=\"https://github.com/Wizzercn/NutzWk\">https://github.com/Wizzercn/NutzWk</a>\n码云Gitee：<a href=\"https://gitee.com/wizzer/NutzWk\">https://gitee.com/wizzer/NutzWk</a></p>\n<p>后端技术架构：nutzboot + dubbo + sentinel + redis + zookeeper\n前端技术架构：vue.js + element.js</p>\n<p>简述：\n自 2018.03.20 发布 v5.0.1 第一个微服务分布式版本、2018.11.13 发布 v5.1.0 第一个Vue版本，一年来 NutzWk 根据项目实践及业务需要，逐步完善功能、修复bug、添加新特性，朝着“快速开发、功能丰富、扩展性强、性能优越”，在力所能及的情况下，最大限度的提高Web开发人员的生产力的目标继续前进。</p>\n<p>随着项目越做越多，运维成了繁重的工作，本次 v5.2.0 版本主要带来了可在线上传jar包、编辑配置文件、关闭实例进程、启动新实例进程、动态修改日志等级、查看服务器资源占用情况等功能，支持分布式部署。详见：<a href=\"https://github.com/Wizzercn/NutzWk/releases\">发行注记</a>。</p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/daba7cc0428f1cb0a626f9e7d70db68863a.jpg\" alt=\"01\"></p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/31af6228e53ee05197caeebb4a1fc683c49.jpg\" alt=\"02\"></p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/0b3dd5e4fe243cb160a7669e41b849e9545.jpg\" alt=\"03\"></p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/ea00c1ef55fb807bc214e04d1e92f76f468.jpg\" alt=\"04\"></p>\n</div>",
            "title": "NutzWk 5.2.0(一周年) 版本，运维中心重磅发布",
            "last_reply_at": "2019-03-19T14:06:39.874Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 358,
            "create_at": "2019-03-19T02:17:08.282Z",
            "author": {
                "loginname": "Wizzercn",
                "avatar_url": "https://avatars0.githubusercontent.com/u/2408114?v=4&s=120"
            }
        }, {
            "id": "5b18a28557137f22415c49e9",
            "author_id": "55d120f3b25bd72150842d85",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h1>前端进阶之困</h1>\n<p>最近看了不少文章和帖子， 如文：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5b124fdd5188257d6c0465da?utm_source=gold_browser_extension\">前端的焦虑，你想过30岁以后的前端路怎么走吗？</a></li>\n<li><a href=\"https://cnodejs.org/topic/5af047150a36e5312d6ecdf0\">前端怎么一步步走向全栈呢？</a></li>\n<li><a href=\"https://cnodejs.org/topic/5b164efa29e6e510415b2803\">移动端入门Node.js怎么学习?</a></li>\n<li><a href=\"https://cnodejs.org/topic/5a4cc04cebc575dc49b270d5\">前端的未来走向在哪里？</a></li>\n<li><a href=\"https://cnodejs.org/topic/5ab1ebb5e7b166bb7b9eccaa\">工作2年多的前端，现在迷茫了，如何更进一步的提升自己</a></li>\n</ul>\n<p>身边和朋友圈也不少做前端开发的同事朋友问如何发展和提升\n这里我向大家给一些建议</p>\n<h2>扎实基础</h2>\n<p>首先思考下手上的工作是否做得足够好了，近几年前端技术发展迅猛各种框架层出不穷，刚学会jquery还没用熟， angular 、vue 、react 已经满大街了。\ngulp 还没明白怎么回事、webpack 已开始遍地开花了。眼花缭乱的技术不知道从哪里开始好。\n如果你还被这些困扰的话，那请静下来思考一下，技术的发展总是有规律的，学习也是有规律可循的，我的建议是，把共性和必要的技能先稳固下来，既不浪费时间，又能提高效率，如果这块还么稳固好、框架什么少看几种吧，先有一样可用的就好。\n对于加强基础一个可行的方案是，从自己上手的工作开始、除了专注现学现用工作需要的框架技术外加强基础的学习，如：</p>\n<ul>\n<li>基本的逻辑（与、或、非）</li>\n<li>运算操作（加减乘除 Math 下的各种函数）</li>\n<li>字符串处理 （什么大小写、编码、裁剪什么的）</li>\n<li>时间处理 （日期的加减、对比、格式转换等）</li>\n<li>数组、集合对象处理\n可以了解学习一些基础库 如: <a href=\"https://github.com/lodash/lodash\">lodash</a>、<a href=\"https://github.com/moment/moment\">moment</a> 等、若时间有限可以看看示例有个印象回头可以查找，当然最好的方式是实践练习。</li>\n</ul>\n<h2>发展全栈的正确姿势</h2>\n<p>Javascript 生态链对于全栈有一些优势，但全栈不是贴金的标签，如果技能不够硬，必然落得个 <strong>前端不强，后端不行</strong> 的尴尬局面。</p>\n<h3>那对于前端是不是不该发展后端呢？</h3>\n<p>回答当然是否定的，前端<em>有目的、有计划的发展后端技能</em>，对于系统全局观、工作协作能力提升是非常有帮助的，<strong>另外切实让老板愿意为你加工资是非常可能的</strong>。</p>\n<h3>那要如何才能是有目的、有计划的发展后端技能呢？</h3>\n<p>首先认清后端技能出发点和关键点。</p>\n<ul>\n<li>出发点: 是主动权和话语权（可能某个后端老是鄙视你，你要的东西，说这个没办法，那个不应该，造成了你工作很被动，效率不高，出错了可能还先找你）。</li>\n<li>关键点: 前后端接口 （如果你能清晰、标准、明确你要的接口，那么一些都会明朗起来）。\n所以我认为前端切入后端应该从接口开始。</li>\n</ul>\n<h3>从标准接口开始，什么样的接口才是标准的呢？</h3>\n<p><a href=\"https://swagger.io/resources/open-api/\">OpenAPI  Specification</a>\n这里我为大家推荐 Swagger 标准接口 (目前有两个标准 OAS 2.0 和 OAS 3.0)\nSwagger 致力于接口的标准化，并为此提供了一系列的工具，方便大家对进口进行标准化。</p>\n<h3>有什么好处呢</h3>\n<ul>\n<li>简化工作流程 (Streamline Your Workflow)。</li>\n<li>自由构建 (Restraint-Free Build)</li>\n<li>开放/全球化的支持 (Open &amp; Globally Supported)\n我的理解是增强系统的健壮性、降低沟通成本、提高写作效率，另外接口是系统的一种抽象可以更好的从宏观把握系统。</li>\n</ul>\n<h3>标准化的接口要如何实践</h3>\n<p>这里我安利下我的开源项目 <a href=\"https://github.com/vellengs/typerx\">typerx</a>, typerx 是一个轻量注解式的全栈系统、你可以使用他快速的实践接口标准的全栈开发。</p>\n<ul>\n<li>创建接口前、我们仍旧还是要考虑接口模块的、模块化的设计能降低我们一次思考的复杂度。\n在 typerx 中我们分了 core 模块和 cms 模块。</li>\n<li>接口的创建从原型开始考虑、确定接口所需的模型 model, 这个模型我们称之为 DTO(data transform object) 也就是接口的输入输出数据对象。\n<a href=\"https://github.com/vellengs/typerx/blob/master/packages/server/src/modules/core/dto\">dto 的编写示例</a></li>\n<li>有了模型之后我们就可以确定需要哪些接口方法了，编写接口的时候先不着急考虑接口的实现，我们只要先提供模型（可以建立一个按模型提供的数据mock)确保必要的接口规格描述就好，\n<a href=\"https://github.com/vellengs/typerx/blob/master/packages/server/src/modules/core/account.controller.ts\">account 的接口定义</a>\n这里我们通过直接编写代码的方式来实现文档，这样方便我们高效、可维护的接口文档（当然先完成文档再来生成代码也是可以的，不过代码能表述的永远比文档能描述的多，所以应该是有一套能够自动生成api 文档的代码来维护比较合适，过去也曾从文档开始，但文档的错漏不方便验证、而且文档维护数据模型是很累的一个事情无法动态关联重构）。</li>\n<li>按要求完成了接口定义之后，你只要轻松运行</li>\n</ul>\n<pre class=\"prettyprint\"><code>npm run build \n</code></pre><p>你就拥有标准的接口文档描述文件 swagger.json / swagger.yaml 了, 你可以使用 typerx 直接启动服务端预览接口 <a href=\"http://localhost:4700/docs\">localhost:4700</a> 或者放到在线编辑器上预览 <a href=\"http://editor.swagger.io/\">editor.swagger.io</a>;</p>\n<ul>\n<li>好了标准话的接口有了你可以保持这个接和后端的接口一致，这样就可以和后端愉快的协作了，当然如果你喜欢，直接使用 typerx 实现自己真实的后端。</li>\n</ul>\n<p>最后欢迎大家关注 <a href=\"https://github.com/vellengs/typerx\">typerx</a> 一起讨论努力进阶。</p>\n</div>",
            "title": "前端如何进阶全栈开发",
            "last_reply_at": "2019-03-19T13:58:42.166Z",
            "good": false,
            "top": false,
            "reply_count": 40,
            "visit_count": 8995,
            "create_at": "2018-06-07T03:12:05.854Z",
            "author": {
                "loginname": "vellengs",
                "avatar_url": "https://avatars1.githubusercontent.com/u/5743338?v=4&s=120"
            }
        }, {
            "id": "5c8cc8d37ce0df3732428a21",
            "author_id": "5c381e903898674067a7e050",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>#好利来公司官网</p>\n<h5></h5>\n<h3>代码目录</h3>\n<pre class=\"prettyprint\"><code>+-- public&#x2F;                                    ---公共样式\n+-- routes&#x2F;                               ---每个页面的路由模块\n+-- view&#x2F;                                 ---静态html\n+-- fail&#x2F;                                   ---入口文件\n+-- app.js&#x2F;\t\t\t\t\t\t\t        ---首页入\n+-- model&#x2F;\t\t\t\t\t\t            ---公共方法\n</code></pre><p>#程序安装方法</p>\n<pre class=\"prettyprint\"><code>1.确保电脑已经安装了NodeJS环境，运行版本尽量保持最新（V8以上吧），选择本地的一个路径，然后运行命令\n$ git clone https:&#x2F;&#x2F;github.com&#x2F;dezhizhang&#x2F;haolilaicompany.git\n2.进入程序的主目录（包含app.js的那个文件夹）运行命令：npm install，系统就会自动安装该程序的依赖包；\n3.启动数据库mongod --dbpath 路径地址\n4.在以上的步骤都执行完成且正确的情况下，就可以在程序主目录下面（有app.js的那个目录）,运行命令\n$ node app.js\n</code></pre><p>GIthub源码：<a href=\"https://github.com/dezhizhang/haolilaicompany\">https://github.com/dezhizhang/haolilaicompany</a>\n<img src=\"https://github.com/dezhizhang/haolilaicompany/blob/master/public/upload/17.png\" alt=\"Image text\">\n<img src=\"https://github.com/dezhizhang/haolilaicompany/blob/master/public/upload/22.png\" alt=\"Image text\">\n<img src=\"https://github.com/dezhizhang/haolilaicompany/blob/master/public/upload/9.png\" alt=\"Image text\">\n<img src=\"https://github.com/dezhizhang/haolilaicompany/blob/master/public/upload/10.png\" alt=\"Image text\">\n<img src=\"https://github.com/dezhizhang/haolilaicompany/blob/master/public/upload/12.png\" alt=\"Image text\"></p>\n</div>",
            "title": "koa2+mongodb开发大型前后台网站",
            "last_reply_at": "2019-03-19T12:25:30.218Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 688,
            "create_at": "2019-03-16T09:58:43.796Z",
            "author": {
                "loginname": "dezhizhang",
                "avatar_url": "https://avatars3.githubusercontent.com/u/28954583?v=4&s=120"
            }
        }]
    },
    "status": 200,
    "statusText": "OK",
    "headers": {
        "x-response-time": "63.008ms",
        "date": "Fri, 22 Mar 2019 14:36:27 GMT",
        "content-encoding": "gzip",
        "vary": "Accept-Encoding",
        "server": "nginx/1.14.0 (Ubuntu)",
        "x-powered-by": "Express",
        "etag": "W/\"220c2-IJHZPAZJK20jLXiURvTTgjSSnAM\"",
        "x-frame-options": "SAMEORIGIN",
        "content-type": "application/json; charset=utf-8",
        "access-control-allow-origin": "*"
    },
    "config": {
        "transformRequest": {},
        "transformResponse": {},
        "timeout": 0,
        "xsrfCookieName": "XSRF-TOKEN",
        "xsrfHeaderName": "X-XSRF-TOKEN",
        "maxContentLength": -1,
        "headers": {
            "Accept": "application/json, text/plain, */*"
        },
        "method": "get",
        "url": "/api/v1/topics",
        "data": null,
        "params": null,
        "baseURL": "/api/v1",
        "withCredentials": false
    },
    "request": {}
}